"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddFolderHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddFolderHeaders = AddFolderHeaders;
class AddFolderRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            option: AddFolderRequestOption,
            unionId: 'string',
        };
    }
}
exports.AddFolderRequest = AddFolderRequest;
class AddFolderResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: AddFolderResponseBodyDentry,
        };
    }
}
exports.AddFolderResponseBody = AddFolderResponseBody;
class AddFolderResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddFolderResponseBody,
        };
    }
}
exports.AddFolderResponse = AddFolderResponse;
class AddSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddSpaceHeaders = AddSpaceHeaders;
class AddSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: AddSpaceRequestOption,
            unionId: 'string',
        };
    }
}
exports.AddSpaceRequest = AddSpaceRequest;
class AddSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            space: 'space',
        };
    }
    static types() {
        return {
            space: AddSpaceResponseBodySpace,
        };
    }
}
exports.AddSpaceResponseBody = AddSpaceResponseBody;
class AddSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddSpaceResponseBody,
        };
    }
}
exports.AddSpaceResponse = AddSpaceResponse;
class ClearRecycleBinHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ClearRecycleBinHeaders = ClearRecycleBinHeaders;
class ClearRecycleBinRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.ClearRecycleBinRequest = ClearRecycleBinRequest;
class ClearRecycleBinResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.ClearRecycleBinResponseBody = ClearRecycleBinResponseBody;
class ClearRecycleBinResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ClearRecycleBinResponseBody,
        };
    }
}
exports.ClearRecycleBinResponse = ClearRecycleBinResponse;
class CommitFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CommitFileHeaders = CommitFileHeaders;
class CommitFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            option: 'option',
            parentId: 'parentId',
            size: 'size',
            uploadKey: 'uploadKey',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            option: CommitFileRequestOption,
            parentId: 'string',
            size: 'number',
            uploadKey: 'string',
            unionId: 'string',
        };
    }
}
exports.CommitFileRequest = CommitFileRequest;
class CommitFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: CommitFileResponseBodyDentry,
        };
    }
}
exports.CommitFileResponseBody = CommitFileResponseBody;
class CommitFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CommitFileResponseBody,
        };
    }
}
exports.CommitFileResponse = CommitFileResponse;
class CopyDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CopyDentryHeaders = CopyDentryHeaders;
class CopyDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            targetFolderId: 'targetFolderId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: CopyDentryRequestOption,
            targetFolderId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.CopyDentryRequest = CopyDentryRequest;
class CopyDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentry: 'dentry',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentry: CopyDentryResponseBodyDentry,
            taskId: 'string',
        };
    }
}
exports.CopyDentryResponseBody = CopyDentryResponseBody;
class CopyDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CopyDentryResponseBody,
        };
    }
}
exports.CopyDentryResponse = CopyDentryResponse;
class DeleteDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteDentryHeaders = DeleteDentryHeaders;
class DeleteDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            toRecycleBin: 'toRecycleBin',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            toRecycleBin: 'boolean',
            unionId: 'string',
        };
    }
}
exports.DeleteDentryRequest = DeleteDentryRequest;
class DeleteDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            taskId: 'string',
        };
    }
}
exports.DeleteDentryResponseBody = DeleteDentryResponseBody;
class DeleteDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteDentryResponseBody,
        };
    }
}
exports.DeleteDentryResponse = DeleteDentryResponse;
class DeleteDentryAppPropertiesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteDentryAppPropertiesHeaders = DeleteDentryAppPropertiesHeaders;
class DeleteDentryAppPropertiesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyNames: 'propertyNames',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            propertyNames: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.DeleteDentryAppPropertiesRequest = DeleteDentryAppPropertiesRequest;
class DeleteDentryAppPropertiesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeleteDentryAppPropertiesResponseBody = DeleteDentryAppPropertiesResponseBody;
class DeleteDentryAppPropertiesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteDentryAppPropertiesResponseBody,
        };
    }
}
exports.DeleteDentryAppPropertiesResponse = DeleteDentryAppPropertiesResponse;
class DeleteRecycleItemHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteRecycleItemHeaders = DeleteRecycleItemHeaders;
class DeleteRecycleItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.DeleteRecycleItemRequest = DeleteRecycleItemRequest;
class DeleteRecycleItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeleteRecycleItemResponseBody = DeleteRecycleItemResponseBody;
class DeleteRecycleItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteRecycleItemResponseBody,
        };
    }
}
exports.DeleteRecycleItemResponse = DeleteRecycleItemResponse;
class DeleteRecycleItemsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteRecycleItemsHeaders = DeleteRecycleItemsHeaders;
class DeleteRecycleItemsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleItemIds: 'recycleItemIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            recycleItemIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.DeleteRecycleItemsRequest = DeleteRecycleItemsRequest;
class DeleteRecycleItemsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeleteRecycleItemsResponseBody = DeleteRecycleItemsResponseBody;
class DeleteRecycleItemsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteRecycleItemsResponseBody,
        };
    }
}
exports.DeleteRecycleItemsResponse = DeleteRecycleItemsResponse;
class GetCurrentAppHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCurrentAppHeaders = GetCurrentAppHeaders;
class GetCurrentAppRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetCurrentAppRequest = GetCurrentAppRequest;
class GetCurrentAppResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            app: 'app',
        };
    }
    static types() {
        return {
            app: GetCurrentAppResponseBodyApp,
        };
    }
}
exports.GetCurrentAppResponseBody = GetCurrentAppResponseBody;
class GetCurrentAppResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetCurrentAppResponseBody,
        };
    }
}
exports.GetCurrentAppResponse = GetCurrentAppResponse;
class GetDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetDentryHeaders = GetDentryHeaders;
class GetDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: GetDentryRequestOption,
            unionId: 'string',
        };
    }
}
exports.GetDentryRequest = GetDentryRequest;
class GetDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: GetDentryResponseBodyDentry,
        };
    }
}
exports.GetDentryResponseBody = GetDentryResponseBody;
class GetDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetDentryResponseBody,
        };
    }
}
exports.GetDentryResponse = GetDentryResponse;
class GetFileDownloadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileDownloadInfoHeaders = GetFileDownloadInfoHeaders;
class GetFileDownloadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: GetFileDownloadInfoRequestOption,
            unionId: 'string',
        };
    }
}
exports.GetFileDownloadInfoRequest = GetFileDownloadInfoRequest;
class GetFileDownloadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headerSignatureInfo: 'headerSignatureInfo',
            protocol: 'protocol',
        };
    }
    static types() {
        return {
            headerSignatureInfo: GetFileDownloadInfoResponseBodyHeaderSignatureInfo,
            protocol: 'string',
        };
    }
}
exports.GetFileDownloadInfoResponseBody = GetFileDownloadInfoResponseBody;
class GetFileDownloadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetFileDownloadInfoResponseBody,
        };
    }
}
exports.GetFileDownloadInfoResponse = GetFileDownloadInfoResponse;
class GetFileUploadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileUploadInfoHeaders = GetFileUploadInfoHeaders;
class GetFileUploadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            multipart: 'multipart',
            option: 'option',
            protocol: 'protocol',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            multipart: 'boolean',
            option: GetFileUploadInfoRequestOption,
            protocol: 'string',
            unionId: 'string',
        };
    }
}
exports.GetFileUploadInfoRequest = GetFileUploadInfoRequest;
class GetFileUploadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headerSignatureInfo: 'headerSignatureInfo',
            protocol: 'protocol',
            storageDriver: 'storageDriver',
            uploadKey: 'uploadKey',
        };
    }
    static types() {
        return {
            headerSignatureInfo: GetFileUploadInfoResponseBodyHeaderSignatureInfo,
            protocol: 'string',
            storageDriver: 'string',
            uploadKey: 'string',
        };
    }
}
exports.GetFileUploadInfoResponseBody = GetFileUploadInfoResponseBody;
class GetFileUploadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetFileUploadInfoResponseBody,
        };
    }
}
exports.GetFileUploadInfoResponse = GetFileUploadInfoResponse;
class GetRecycleBinHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetRecycleBinHeaders = GetRecycleBinHeaders;
class GetRecycleBinRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleBinScope: 'recycleBinScope',
            scopeId: 'scopeId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            recycleBinScope: 'string',
            scopeId: 'string',
            unionId: 'string',
        };
    }
}
exports.GetRecycleBinRequest = GetRecycleBinRequest;
class GetRecycleBinResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleBin: 'recycleBin',
        };
    }
    static types() {
        return {
            recycleBin: GetRecycleBinResponseBodyRecycleBin,
        };
    }
}
exports.GetRecycleBinResponseBody = GetRecycleBinResponseBody;
class GetRecycleBinResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetRecycleBinResponseBody,
        };
    }
}
exports.GetRecycleBinResponse = GetRecycleBinResponse;
class GetRecycleItemHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetRecycleItemHeaders = GetRecycleItemHeaders;
class GetRecycleItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetRecycleItemRequest = GetRecycleItemRequest;
class GetRecycleItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: GetRecycleItemResponseBodyItem,
        };
    }
}
exports.GetRecycleItemResponseBody = GetRecycleItemResponseBody;
class GetRecycleItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetRecycleItemResponseBody,
        };
    }
}
exports.GetRecycleItemResponse = GetRecycleItemResponse;
class GetSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSpaceHeaders = GetSpaceHeaders;
class GetSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetSpaceRequest = GetSpaceRequest;
class GetSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            space: 'space',
        };
    }
    static types() {
        return {
            space: GetSpaceResponseBodySpace,
        };
    }
}
exports.GetSpaceResponseBody = GetSpaceResponseBody;
class GetSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetSpaceResponseBody,
        };
    }
}
exports.GetSpaceResponse = GetSpaceResponse;
class ListDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListDentriesHeaders = ListDentriesHeaders;
class ListDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            order: 'order',
            orderBy: 'orderBy',
            parentId: 'parentId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            order: 'string',
            orderBy: 'string',
            parentId: 'string',
            unionId: 'string',
        };
    }
}
exports.ListDentriesRequest = ListDentriesRequest;
class ListDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentries: 'dentries',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            dentries: { 'type': 'array', 'itemType': ListDentriesResponseBodyDentries },
            nextToken: 'string',
        };
    }
}
exports.ListDentriesResponseBody = ListDentriesResponseBody;
class ListDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListDentriesResponseBody,
        };
    }
}
exports.ListDentriesResponse = ListDentriesResponse;
class ListDentryVersionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListDentryVersionsHeaders = ListDentryVersionsHeaders;
class ListDentryVersionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            unionId: 'string',
        };
    }
}
exports.ListDentryVersionsRequest = ListDentryVersionsRequest;
class ListDentryVersionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentries: 'dentries',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            dentries: { 'type': 'array', 'itemType': ListDentryVersionsResponseBodyDentries },
            nextToken: 'string',
        };
    }
}
exports.ListDentryVersionsResponseBody = ListDentryVersionsResponseBody;
class ListDentryVersionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListDentryVersionsResponseBody,
        };
    }
}
exports.ListDentryVersionsResponse = ListDentryVersionsResponse;
class ListRecycleItemsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListRecycleItemsHeaders = ListRecycleItemsHeaders;
class ListRecycleItemsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            unionId: 'string',
        };
    }
}
exports.ListRecycleItemsRequest = ListRecycleItemsRequest;
class ListRecycleItemsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            recycleItems: 'recycleItems',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            recycleItems: { 'type': 'array', 'itemType': ListRecycleItemsResponseBodyRecycleItems },
        };
    }
}
exports.ListRecycleItemsResponseBody = ListRecycleItemsResponseBody;
class ListRecycleItemsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListRecycleItemsResponseBody,
        };
    }
}
exports.ListRecycleItemsResponse = ListRecycleItemsResponse;
class MoveDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MoveDentryHeaders = MoveDentryHeaders;
class MoveDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            targetFolderId: 'targetFolderId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: MoveDentryRequestOption,
            targetFolderId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.MoveDentryRequest = MoveDentryRequest;
class MoveDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentry: 'dentry',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentry: MoveDentryResponseBodyDentry,
            taskId: 'string',
        };
    }
}
exports.MoveDentryResponseBody = MoveDentryResponseBody;
class MoveDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: MoveDentryResponseBody,
        };
    }
}
exports.MoveDentryResponse = MoveDentryResponse;
class RenameDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RenameDentryHeaders = RenameDentryHeaders;
class RenameDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            newName: 'newName',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            newName: 'string',
            unionId: 'string',
        };
    }
}
exports.RenameDentryRequest = RenameDentryRequest;
class RenameDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: RenameDentryResponseBodyDentry,
        };
    }
}
exports.RenameDentryResponseBody = RenameDentryResponseBody;
class RenameDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: RenameDentryResponseBody,
        };
    }
}
exports.RenameDentryResponse = RenameDentryResponse;
class RestoreRecycleItemHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RestoreRecycleItemHeaders = RestoreRecycleItemHeaders;
class RestoreRecycleItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: RestoreRecycleItemRequestOption,
            unionId: 'string',
        };
    }
}
exports.RestoreRecycleItemRequest = RestoreRecycleItemRequest;
class RestoreRecycleItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.RestoreRecycleItemResponseBody = RestoreRecycleItemResponseBody;
class RestoreRecycleItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: RestoreRecycleItemResponseBody,
        };
    }
}
exports.RestoreRecycleItemResponse = RestoreRecycleItemResponse;
class RevertDentryVersionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RevertDentryVersionHeaders = RevertDentryVersionHeaders;
class RevertDentryVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.RevertDentryVersionRequest = RevertDentryVersionRequest;
class RevertDentryVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.RevertDentryVersionResponseBody = RevertDentryVersionResponseBody;
class RevertDentryVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: RevertDentryVersionResponseBody,
        };
    }
}
exports.RevertDentryVersionResponse = RevertDentryVersionResponse;
class UpdateDentryAppPropertiesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateDentryAppPropertiesHeaders = UpdateDentryAppPropertiesHeaders;
class UpdateDentryAppPropertiesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'array', 'itemType': UpdateDentryAppPropertiesRequestAppProperties },
            unionId: 'string',
        };
    }
}
exports.UpdateDentryAppPropertiesRequest = UpdateDentryAppPropertiesRequest;
class UpdateDentryAppPropertiesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdateDentryAppPropertiesResponseBody = UpdateDentryAppPropertiesResponseBody;
class UpdateDentryAppPropertiesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateDentryAppPropertiesResponseBody,
        };
    }
}
exports.UpdateDentryAppPropertiesResponse = UpdateDentryAppPropertiesResponse;
class DentryAppPropertiesValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.DentryAppPropertiesValue = DentryAppPropertiesValue;
class DentriesAppPropertiesValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.DentriesAppPropertiesValue = DentriesAppPropertiesValue;
class AddFolderRequestOptionAppProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.AddFolderRequestOptionAppProperties = AddFolderRequestOptionAppProperties;
class AddFolderRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'array', 'itemType': AddFolderRequestOptionAppProperties },
            conflictStrategy: 'string',
        };
    }
}
exports.AddFolderRequestOption = AddFolderRequestOption;
class AddFolderResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.AddFolderResponseBodyDentryProperties = AddFolderResponseBodyDentryProperties;
class AddFolderResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: AddFolderResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.AddFolderResponseBodyDentry = AddFolderResponseBodyDentry;
class AddSpaceRequestOptionCapabilities extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            canRecordRecentFile: 'canRecordRecentFile',
            canRename: 'canRename',
            canSearch: 'canSearch',
        };
    }
    static types() {
        return {
            canRecordRecentFile: 'boolean',
            canRename: 'boolean',
            canSearch: 'boolean',
        };
    }
}
exports.AddSpaceRequestOptionCapabilities = AddSpaceRequestOptionCapabilities;
class AddSpaceRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            capabilities: 'capabilities',
            name: 'name',
            ownerType: 'ownerType',
            quota: 'quota',
            scene: 'scene',
            sceneId: 'sceneId',
        };
    }
    static types() {
        return {
            capabilities: AddSpaceRequestOptionCapabilities,
            name: 'string',
            ownerType: 'string',
            quota: 'number',
            scene: 'string',
            sceneId: 'string',
        };
    }
}
exports.AddSpaceRequestOption = AddSpaceRequestOption;
class AddSpaceResponseBodySpaceCapabilities extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            canRecordRecentFile: 'canRecordRecentFile',
            canRename: 'canRename',
            canSearch: 'canSearch',
        };
    }
    static types() {
        return {
            canRecordRecentFile: 'boolean',
            canRename: 'boolean',
            canSearch: 'boolean',
        };
    }
}
exports.AddSpaceResponseBodySpaceCapabilities = AddSpaceResponseBodySpaceCapabilities;
class AddSpaceResponseBodySpace extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            capabilities: 'capabilities',
            corpId: 'corpId',
            createTime: 'createTime',
            creatorId: 'creatorId',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            ownerId: 'ownerId',
            ownerType: 'ownerType',
            quota: 'quota',
            scene: 'scene',
            sceneId: 'sceneId',
            status: 'status',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            appId: 'string',
            capabilities: AddSpaceResponseBodySpaceCapabilities,
            corpId: 'string',
            createTime: 'string',
            creatorId: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            ownerId: 'string',
            ownerType: 'string',
            quota: 'number',
            scene: 'string',
            sceneId: 'string',
            status: 'string',
            usedQuota: 'number',
        };
    }
}
exports.AddSpaceResponseBodySpace = AddSpaceResponseBodySpace;
class CommitFileRequestOptionAppProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.CommitFileRequestOptionAppProperties = CommitFileRequestOptionAppProperties;
class CommitFileRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'array', 'itemType': CommitFileRequestOptionAppProperties },
            conflictStrategy: 'string',
        };
    }
}
exports.CommitFileRequestOption = CommitFileRequestOption;
class CommitFileResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.CommitFileResponseBodyDentryProperties = CommitFileResponseBodyDentryProperties;
class CommitFileResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: CommitFileResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.CommitFileResponseBodyDentry = CommitFileResponseBodyDentry;
class CopyDentryRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
        };
    }
}
exports.CopyDentryRequestOption = CopyDentryRequestOption;
class CopyDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.CopyDentryResponseBodyDentryProperties = CopyDentryResponseBodyDentryProperties;
class CopyDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: CopyDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.CopyDentryResponseBodyDentry = CopyDentryResponseBodyDentry;
class GetCurrentAppResponseBodyAppPartitionsQuota extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            max: 'max',
            type: 'type',
            used: 'used',
        };
    }
    static types() {
        return {
            max: 'number',
            type: 'string',
            used: 'number',
        };
    }
}
exports.GetCurrentAppResponseBodyAppPartitionsQuota = GetCurrentAppResponseBodyAppPartitionsQuota;
class GetCurrentAppResponseBodyAppPartitions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partitionType: 'partitionType',
            quota: 'quota',
        };
    }
    static types() {
        return {
            partitionType: 'string',
            quota: GetCurrentAppResponseBodyAppPartitionsQuota,
        };
    }
}
exports.GetCurrentAppResponseBodyAppPartitions = GetCurrentAppResponseBodyAppPartitions;
class GetCurrentAppResponseBodyApp extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            corpId: 'corpId',
            createTime: 'createTime',
            modifiedTime: 'modifiedTime',
            name: 'name',
            partitions: 'partitions',
        };
    }
    static types() {
        return {
            appId: 'string',
            corpId: 'string',
            createTime: 'string',
            modifiedTime: 'string',
            name: 'string',
            partitions: { 'type': 'array', 'itemType': GetCurrentAppResponseBodyAppPartitions },
        };
    }
}
exports.GetCurrentAppResponseBodyApp = GetCurrentAppResponseBodyApp;
class GetDentryRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appIdsForAppProperties: 'appIdsForAppProperties',
        };
    }
    static types() {
        return {
            appIdsForAppProperties: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetDentryRequestOption = GetDentryRequestOption;
class GetDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.GetDentryResponseBodyDentryProperties = GetDentryResponseBodyDentryProperties;
class GetDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: GetDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.GetDentryResponseBodyDentry = GetDentryResponseBodyDentry;
class GetFileDownloadInfoRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            version: 'version',
        };
    }
    static types() {
        return {
            version: 'number',
        };
    }
}
exports.GetFileDownloadInfoRequestOption = GetFileDownloadInfoRequestOption;
class GetFileDownloadInfoResponseBodyHeaderSignatureInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationSeconds: 'expirationSeconds',
            headers: 'headers',
            internalResourceUrls: 'internalResourceUrls',
            region: 'region',
            resourceUrls: 'resourceUrls',
        };
    }
    static types() {
        return {
            expirationSeconds: 'number',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            internalResourceUrls: { 'type': 'array', 'itemType': 'string' },
            region: 'string',
            resourceUrls: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetFileDownloadInfoResponseBodyHeaderSignatureInfo = GetFileDownloadInfoResponseBodyHeaderSignatureInfo;
class GetFileUploadInfoRequestOptionPreCheckParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            md5: 'md5',
            name: 'name',
            parentId: 'parentId',
            size: 'size',
        };
    }
    static types() {
        return {
            md5: 'string',
            name: 'string',
            parentId: 'string',
            size: 'number',
        };
    }
}
exports.GetFileUploadInfoRequestOptionPreCheckParam = GetFileUploadInfoRequestOptionPreCheckParam;
class GetFileUploadInfoRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            preCheckParam: 'preCheckParam',
            preferRegion: 'preferRegion',
            storageDriver: 'storageDriver',
        };
    }
    static types() {
        return {
            preCheckParam: GetFileUploadInfoRequestOptionPreCheckParam,
            preferRegion: 'string',
            storageDriver: 'string',
        };
    }
}
exports.GetFileUploadInfoRequestOption = GetFileUploadInfoRequestOption;
class GetFileUploadInfoResponseBodyHeaderSignatureInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationSeconds: 'expirationSeconds',
            headers: 'headers',
            internalResourceUrls: 'internalResourceUrls',
            region: 'region',
            resourceUrls: 'resourceUrls',
        };
    }
    static types() {
        return {
            expirationSeconds: 'number',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            internalResourceUrls: { 'type': 'array', 'itemType': 'string' },
            region: 'string',
            resourceUrls: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetFileUploadInfoResponseBodyHeaderSignatureInfo = GetFileUploadInfoResponseBodyHeaderSignatureInfo;
class GetRecycleBinResponseBodyRecycleBin extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            scope: 'scope',
            scopeId: 'scopeId',
        };
    }
    static types() {
        return {
            id: 'string',
            scope: 'string',
            scopeId: 'string',
        };
    }
}
exports.GetRecycleBinResponseBodyRecycleBin = GetRecycleBinResponseBodyRecycleBin;
class GetRecycleItemResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            dentryId: 'dentryId',
            id: 'id',
            operatorId: 'operatorId',
            operatorTime: 'operatorTime',
            originalName: 'originalName',
            originalPath: 'originalPath',
            size: 'size',
            spaceId: 'spaceId',
            type: 'type',
        };
    }
    static types() {
        return {
            appId: 'string',
            dentryId: 'string',
            id: 'string',
            operatorId: 'string',
            operatorTime: 'string',
            originalName: 'string',
            originalPath: 'string',
            size: 'number',
            spaceId: 'string',
            type: 'string',
        };
    }
}
exports.GetRecycleItemResponseBodyItem = GetRecycleItemResponseBodyItem;
class GetSpaceResponseBodySpaceCapabilities extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            canRecordRecentFile: 'canRecordRecentFile',
            canRename: 'canRename',
            canSearch: 'canSearch',
        };
    }
    static types() {
        return {
            canRecordRecentFile: 'boolean',
            canRename: 'boolean',
            canSearch: 'boolean',
        };
    }
}
exports.GetSpaceResponseBodySpaceCapabilities = GetSpaceResponseBodySpaceCapabilities;
class GetSpaceResponseBodySpace extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            capabilities: 'capabilities',
            corpId: 'corpId',
            createTime: 'createTime',
            creatorId: 'creatorId',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            ownerId: 'ownerId',
            ownerType: 'ownerType',
            quota: 'quota',
            scene: 'scene',
            sceneId: 'sceneId',
            status: 'status',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            appId: 'string',
            capabilities: GetSpaceResponseBodySpaceCapabilities,
            corpId: 'string',
            createTime: 'string',
            creatorId: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            ownerId: 'string',
            ownerType: 'string',
            quota: 'number',
            scene: 'string',
            sceneId: 'string',
            status: 'string',
            usedQuota: 'number',
        };
    }
}
exports.GetSpaceResponseBodySpace = GetSpaceResponseBodySpace;
class ListDentriesResponseBodyDentriesProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.ListDentriesResponseBodyDentriesProperties = ListDentriesResponseBodyDentriesProperties;
class ListDentriesResponseBodyDentries extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentriesAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: ListDentriesResponseBodyDentriesProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.ListDentriesResponseBodyDentries = ListDentriesResponseBodyDentries;
class ListDentryVersionsResponseBodyDentriesProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.ListDentryVersionsResponseBodyDentriesProperties = ListDentryVersionsResponseBodyDentriesProperties;
class ListDentryVersionsResponseBodyDentries extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentriesAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: ListDentryVersionsResponseBodyDentriesProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.ListDentryVersionsResponseBodyDentries = ListDentryVersionsResponseBodyDentries;
class ListRecycleItemsResponseBodyRecycleItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            dentryId: 'dentryId',
            id: 'id',
            operatorId: 'operatorId',
            operatorTime: 'operatorTime',
            originalName: 'originalName',
            originalPath: 'originalPath',
            size: 'size',
            spaceId: 'spaceId',
            type: 'type',
        };
    }
    static types() {
        return {
            appId: 'string',
            dentryId: 'string',
            id: 'string',
            operatorId: 'string',
            operatorTime: 'string',
            originalName: 'string',
            originalPath: 'string',
            size: 'number',
            spaceId: 'string',
            type: 'string',
        };
    }
}
exports.ListRecycleItemsResponseBodyRecycleItems = ListRecycleItemsResponseBodyRecycleItems;
class MoveDentryRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
            presevePermissions: 'presevePermissions',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
            presevePermissions: 'boolean',
        };
    }
}
exports.MoveDentryRequestOption = MoveDentryRequestOption;
class MoveDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.MoveDentryResponseBodyDentryProperties = MoveDentryResponseBodyDentryProperties;
class MoveDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: MoveDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.MoveDentryResponseBodyDentry = MoveDentryResponseBodyDentry;
class RenameDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.RenameDentryResponseBodyDentryProperties = RenameDentryResponseBodyDentryProperties;
class RenameDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: RenameDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.RenameDentryResponseBodyDentry = RenameDentryResponseBodyDentry;
class RestoreRecycleItemRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
        };
    }
}
exports.RestoreRecycleItemRequestOption = RestoreRecycleItemRequestOption;
class UpdateDentryAppPropertiesRequestAppProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.UpdateDentryAppPropertiesRequestAppProperties = UpdateDentryAppPropertiesRequestAppProperties;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addFolder(spaceId, parentId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddFolderHeaders({});
        return await this.addFolderWithOptions(spaceId, parentId, request, headers, runtime);
    }
    async addFolderWithOptions(spaceId, parentId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        parentId = openapi_util_1.default.getEncodeParam(parentId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddFolder", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${parentId}/folders`, "json", req, runtime), new AddFolderResponse({}));
    }
    async addSpace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddSpaceHeaders({});
        return await this.addSpaceWithOptions(request, headers, runtime);
    }
    async addSpaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddSpace", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces`, "json", req, runtime), new AddSpaceResponse({}));
    }
    async clearRecycleBin(recycleBinId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ClearRecycleBinHeaders({});
        return await this.clearRecycleBinWithOptions(recycleBinId, request, headers, runtime);
    }
    async clearRecycleBinWithOptions(recycleBinId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        recycleBinId = openapi_util_1.default.getEncodeParam(recycleBinId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ClearRecycleBin", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/recycleBins/${recycleBinId}/clear`, "json", req, runtime), new ClearRecycleBinResponse({}));
    }
    async commitFile(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CommitFileHeaders({});
        return await this.commitFileWithOptions(spaceId, request, headers, runtime);
    }
    async commitFileWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.parentId)) {
            body["parentId"] = request.parentId;
        }
        if (!tea_util_1.default.isUnset(request.size)) {
            body["size"] = request.size;
        }
        if (!tea_util_1.default.isUnset(request.uploadKey)) {
            body["uploadKey"] = request.uploadKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CommitFile", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/files/commit`, "json", req, runtime), new CommitFileResponse({}));
    }
    async copyDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CopyDentryHeaders({});
        return await this.copyDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async copyDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.targetFolderId)) {
            body["targetFolderId"] = request.targetFolderId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CopyDentry", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/copy`, "json", req, runtime), new CopyDentryResponse({}));
    }
    async deleteDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteDentryHeaders({});
        return await this.deleteDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async deleteDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.toRecycleBin)) {
            query["toRecycleBin"] = request.toRecycleBin;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("DeleteDentry", "storage_1.0", "HTTP", "DELETE", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}`, "json", req, runtime), new DeleteDentryResponse({}));
    }
    async deleteDentryAppProperties(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteDentryAppPropertiesHeaders({});
        return await this.deleteDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async deleteDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.propertyNames)) {
            body["propertyNames"] = request.propertyNames;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("DeleteDentryAppProperties", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/appProperties/remove`, "json", req, runtime), new DeleteDentryAppPropertiesResponse({}));
    }
    async deleteRecycleItem(recycleBinId, recycleItemId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRecycleItemHeaders({});
        return await this.deleteRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime);
    }
    async deleteRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        recycleBinId = openapi_util_1.default.getEncodeParam(recycleBinId);
        recycleItemId = openapi_util_1.default.getEncodeParam(recycleItemId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("DeleteRecycleItem", "storage_1.0", "HTTP", "DELETE", "AK", `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/${recycleItemId}`, "json", req, runtime), new DeleteRecycleItemResponse({}));
    }
    async deleteRecycleItems(recycleBinId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRecycleItemsHeaders({});
        return await this.deleteRecycleItemsWithOptions(recycleBinId, request, headers, runtime);
    }
    async deleteRecycleItemsWithOptions(recycleBinId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        recycleBinId = openapi_util_1.default.getEncodeParam(recycleBinId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.recycleItemIds)) {
            body["recycleItemIds"] = request.recycleItemIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("DeleteRecycleItems", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/batchRemove`, "json", req, runtime), new DeleteRecycleItemsResponse({}));
    }
    async getCurrentApp(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCurrentAppHeaders({});
        return await this.getCurrentAppWithOptions(request, headers, runtime);
    }
    async getCurrentAppWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetCurrentApp", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/currentApps/query`, "json", req, runtime), new GetCurrentAppResponse({}));
    }
    async getDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDentryHeaders({});
        return await this.getDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async getDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GetDentry", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/query`, "json", req, runtime), new GetDentryResponse({}));
    }
    async getFileDownloadInfo(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileDownloadInfoHeaders({});
        return await this.getFileDownloadInfoWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async getFileDownloadInfoWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GetFileDownloadInfo", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/downloadInfos/query`, "json", req, runtime), new GetFileDownloadInfoResponse({}));
    }
    async getFileUploadInfo(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileUploadInfoHeaders({});
        return await this.getFileUploadInfoWithOptions(spaceId, request, headers, runtime);
    }
    async getFileUploadInfoWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.multipart)) {
            body["multipart"] = request.multipart;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.protocol)) {
            body["protocol"] = request.protocol;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GetFileUploadInfo", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/files/uploadInfos/query`, "json", req, runtime), new GetFileUploadInfoResponse({}));
    }
    async getRecycleBin(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRecycleBinHeaders({});
        return await this.getRecycleBinWithOptions(request, headers, runtime);
    }
    async getRecycleBinWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.recycleBinScope)) {
            query["recycleBinScope"] = request.recycleBinScope;
        }
        if (!tea_util_1.default.isUnset(request.scopeId)) {
            query["scopeId"] = request.scopeId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetRecycleBin", "storage_1.0", "HTTP", "GET", "AK", `/v1.0/storage/recycleBins`, "json", req, runtime), new GetRecycleBinResponse({}));
    }
    async getRecycleItem(recycleBinId, recycleItemId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRecycleItemHeaders({});
        return await this.getRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime);
    }
    async getRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        recycleBinId = openapi_util_1.default.getEncodeParam(recycleBinId);
        recycleItemId = openapi_util_1.default.getEncodeParam(recycleItemId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetRecycleItem", "storage_1.0", "HTTP", "GET", "AK", `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/${recycleItemId}`, "json", req, runtime), new GetRecycleItemResponse({}));
    }
    async getSpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSpaceHeaders({});
        return await this.getSpaceWithOptions(spaceId, request, headers, runtime);
    }
    async getSpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetSpace", "storage_1.0", "HTTP", "GET", "AK", `/v1.0/storage/spaces/${spaceId}`, "json", req, runtime), new GetSpaceResponse({}));
    }
    async listDentries(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListDentriesHeaders({});
        return await this.listDentriesWithOptions(spaceId, request, headers, runtime);
    }
    async listDentriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.order)) {
            query["order"] = request.order;
        }
        if (!tea_util_1.default.isUnset(request.orderBy)) {
            query["orderBy"] = request.orderBy;
        }
        if (!tea_util_1.default.isUnset(request.parentId)) {
            query["parentId"] = request.parentId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListDentries", "storage_1.0", "HTTP", "GET", "AK", `/v1.0/storage/spaces/${spaceId}/dentries`, "json", req, runtime), new ListDentriesResponse({}));
    }
    async listDentryVersions(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListDentryVersionsHeaders({});
        return await this.listDentryVersionsWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async listDentryVersionsWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListDentryVersions", "storage_1.0", "HTTP", "GET", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/versions`, "json", req, runtime), new ListDentryVersionsResponse({}));
    }
    async listRecycleItems(recycleBinId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListRecycleItemsHeaders({});
        return await this.listRecycleItemsWithOptions(recycleBinId, request, headers, runtime);
    }
    async listRecycleItemsWithOptions(recycleBinId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        recycleBinId = openapi_util_1.default.getEncodeParam(recycleBinId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListRecycleItems", "storage_1.0", "HTTP", "GET", "AK", `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems`, "json", req, runtime), new ListRecycleItemsResponse({}));
    }
    async moveDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MoveDentryHeaders({});
        return await this.moveDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async moveDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.targetFolderId)) {
            body["targetFolderId"] = request.targetFolderId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("MoveDentry", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/move`, "json", req, runtime), new MoveDentryResponse({}));
    }
    async renameDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RenameDentryHeaders({});
        return await this.renameDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async renameDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.newName)) {
            body["newName"] = request.newName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RenameDentry", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/rename`, "json", req, runtime), new RenameDentryResponse({}));
    }
    async restoreRecycleItem(recycleBinId, recycleItemId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RestoreRecycleItemHeaders({});
        return await this.restoreRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime);
    }
    async restoreRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        recycleBinId = openapi_util_1.default.getEncodeParam(recycleBinId);
        recycleItemId = openapi_util_1.default.getEncodeParam(recycleItemId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.option))) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RestoreRecycleItem", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/${recycleItemId}/restore`, "json", req, runtime), new RestoreRecycleItemResponse({}));
    }
    async revertDentryVersion(spaceId, dentryId, version, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RevertDentryVersionHeaders({});
        return await this.revertDentryVersionWithOptions(spaceId, dentryId, version, request, headers, runtime);
    }
    async revertDentryVersionWithOptions(spaceId, dentryId, version, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        version = openapi_util_1.default.getEncodeParam(version);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("RevertDentryVersion", "storage_1.0", "HTTP", "POST", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/versions/${version}/revert`, "json", req, runtime), new RevertDentryVersionResponse({}));
    }
    async updateDentryAppProperties(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateDentryAppPropertiesHeaders({});
        return await this.updateDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async updateDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.appProperties)) {
            body["appProperties"] = request.appProperties;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateDentryAppProperties", "storage_1.0", "HTTP", "PUT", "AK", `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/appProperties`, "json", req, runtime), new UpdateDentryAppPropertiesResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map