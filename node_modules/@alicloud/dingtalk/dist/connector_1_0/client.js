"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class CreateActionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateActionHeaders = CreateActionHeaders;
class CreateActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionInfo: 'actionInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            actionInfo: { 'type': 'array', 'itemType': CreateActionRequestActionInfo },
            integratorFlag: 'string',
        };
    }
}
exports.CreateActionRequest = CreateActionRequest;
class CreateActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': CreateActionResponseBodyItem },
        };
    }
}
exports.CreateActionResponseBody = CreateActionResponseBody;
class CreateActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateActionResponseBody,
        };
    }
}
exports.CreateActionResponse = CreateActionResponse;
class CreateConnectorHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateConnectorHeaders = CreateConnectorHeaders;
class CreateConnectorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectorInfo: 'connectorInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            connectorInfo: { 'type': 'array', 'itemType': CreateConnectorRequestConnectorInfo },
            integratorFlag: 'string',
        };
    }
}
exports.CreateConnectorRequest = CreateConnectorRequest;
class CreateConnectorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': CreateConnectorResponseBodyItem },
        };
    }
}
exports.CreateConnectorResponseBody = CreateConnectorResponseBody;
class CreateConnectorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateConnectorResponseBody,
        };
    }
}
exports.CreateConnectorResponse = CreateConnectorResponse;
class CreateTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateTriggerHeaders = CreateTriggerHeaders;
class CreateTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            integratorFlag: 'integratorFlag',
            triggerInfo: 'triggerInfo',
        };
    }
    static types() {
        return {
            integratorFlag: 'string',
            triggerInfo: { 'type': 'array', 'itemType': CreateTriggerRequestTriggerInfo },
        };
    }
}
exports.CreateTriggerRequest = CreateTriggerRequest;
class CreateTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': CreateTriggerResponseBodyItem },
        };
    }
}
exports.CreateTriggerResponseBody = CreateTriggerResponseBody;
class CreateTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateTriggerResponseBody,
        };
    }
}
exports.CreateTriggerResponse = CreateTriggerResponse;
class PullDataByPageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PullDataByPageHeaders = PullDataByPageHeaders;
class PullDataByPageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            dataModelId: 'dataModelId',
            datetimeFilterField: 'datetimeFilterField',
            maxDatetime: 'maxDatetime',
            maxResults: 'maxResults',
            minDatetime: 'minDatetime',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            appId: 'string',
            dataModelId: 'string',
            datetimeFilterField: 'string',
            maxDatetime: 'number',
            maxResults: 'number',
            minDatetime: 'number',
            nextToken: 'string',
        };
    }
}
exports.PullDataByPageRequest = PullDataByPageRequest;
class PullDataByPageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': PullDataByPageResponseBodyList },
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.PullDataByPageResponseBody = PullDataByPageResponseBody;
class PullDataByPageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: PullDataByPageResponseBody,
        };
    }
}
exports.PullDataByPageResponse = PullDataByPageResponse;
class PullDataByPkHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PullDataByPkHeaders = PullDataByPkHeaders;
class PullDataByPkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            primaryKey: 'primaryKey',
        };
    }
    static types() {
        return {
            appId: 'string',
            primaryKey: 'string',
        };
    }
}
exports.PullDataByPkRequest = PullDataByPkRequest;
class PullDataByPkResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataCreateAppId: 'dataCreateAppId',
            dataCreateAppType: 'dataCreateAppType',
            dataGmtCreate: 'dataGmtCreate',
            dataGmtModified: 'dataGmtModified',
            dataModifiedAppId: 'dataModifiedAppId',
            dataModifiedAppType: 'dataModifiedAppType',
            jsonData: 'jsonData',
        };
    }
    static types() {
        return {
            dataCreateAppId: 'string',
            dataCreateAppType: 'string',
            dataGmtCreate: 'number',
            dataGmtModified: 'number',
            dataModifiedAppId: 'string',
            dataModifiedAppType: 'string',
            jsonData: 'string',
        };
    }
}
exports.PullDataByPkResponseBody = PullDataByPkResponseBody;
class PullDataByPkResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: PullDataByPkResponseBody,
        };
    }
}
exports.PullDataByPkResponse = PullDataByPkResponse;
class SyncDataHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SyncDataHeaders = SyncDataHeaders;
class SyncDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            triggerDataList: 'triggerDataList',
        };
    }
    static types() {
        return {
            appId: 'string',
            triggerDataList: { 'type': 'array', 'itemType': SyncDataRequestTriggerDataList },
        };
    }
}
exports.SyncDataRequest = SyncDataRequest;
class SyncDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': SyncDataResponseBodyList },
        };
    }
}
exports.SyncDataResponseBody = SyncDataResponseBody;
class SyncDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SyncDataResponseBody,
        };
    }
}
exports.SyncDataResponse = SyncDataResponse;
class UpdateActionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateActionHeaders = UpdateActionHeaders;
class UpdateActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionInfo: 'actionInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            actionInfo: { 'type': 'array', 'itemType': UpdateActionRequestActionInfo },
            integratorFlag: 'string',
        };
    }
}
exports.UpdateActionRequest = UpdateActionRequest;
class UpdateActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': UpdateActionResponseBodyItem },
        };
    }
}
exports.UpdateActionResponseBody = UpdateActionResponseBody;
class UpdateActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateActionResponseBody,
        };
    }
}
exports.UpdateActionResponse = UpdateActionResponse;
class UpdateConnectorHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateConnectorHeaders = UpdateConnectorHeaders;
class UpdateConnectorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectorInfo: 'connectorInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            connectorInfo: { 'type': 'array', 'itemType': UpdateConnectorRequestConnectorInfo },
            integratorFlag: 'string',
        };
    }
}
exports.UpdateConnectorRequest = UpdateConnectorRequest;
class UpdateConnectorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': UpdateConnectorResponseBodyItem },
        };
    }
}
exports.UpdateConnectorResponseBody = UpdateConnectorResponseBody;
class UpdateConnectorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateConnectorResponseBody,
        };
    }
}
exports.UpdateConnectorResponse = UpdateConnectorResponse;
class UpdateTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateTriggerHeaders = UpdateTriggerHeaders;
class UpdateTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            integratorFlag: 'integratorFlag',
            triggerInfo: 'triggerInfo',
        };
    }
    static types() {
        return {
            integratorFlag: 'string',
            triggerInfo: { 'type': 'array', 'itemType': UpdateTriggerRequestTriggerInfo },
        };
    }
}
exports.UpdateTriggerRequest = UpdateTriggerRequest;
class UpdateTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': UpdateTriggerResponseBodyItem },
        };
    }
}
exports.UpdateTriggerResponseBody = UpdateTriggerResponseBody;
class UpdateTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateTriggerResponseBody,
        };
    }
}
exports.UpdateTriggerResponse = UpdateTriggerResponse;
class CreateActionRequestActionInfoInputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.CreateActionRequestActionInfoInputMappingConfig = CreateActionRequestActionInfoInputMappingConfig;
class CreateActionRequestActionInfoOutputDataRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expectValue: 'expectValue',
            operate: 'operate',
            propertyPath: 'propertyPath',
        };
    }
    static types() {
        return {
            expectValue: 'string',
            operate: 'string',
            propertyPath: 'string',
        };
    }
}
exports.CreateActionRequestActionInfoOutputDataRules = CreateActionRequestActionInfoOutputDataRules;
class CreateActionRequestActionInfoOutputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.CreateActionRequestActionInfoOutputMappingConfig = CreateActionRequestActionInfoOutputMappingConfig;
class CreateActionRequestActionInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiPath: 'apiPath',
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            inputMappingConfig: 'inputMappingConfig',
            inputSchema: 'inputSchema',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
            outputDataRules: 'outputDataRules',
            outputMappingConfig: 'outputMappingConfig',
            outputSchema: 'outputSchema',
        };
    }
    static types() {
        return {
            apiPath: 'string',
            description: 'string',
            dingConnectorId: 'string',
            inputMappingConfig: CreateActionRequestActionInfoInputMappingConfig,
            inputSchema: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
            outputDataRules: { 'type': 'array', 'itemType': CreateActionRequestActionInfoOutputDataRules },
            outputMappingConfig: CreateActionRequestActionInfoOutputMappingConfig,
            outputSchema: 'string',
        };
    }
}
exports.CreateActionRequestActionInfo = CreateActionRequestActionInfo;
class CreateActionResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingActionId: 'dingActionId',
            dingConnectorId: 'dingConnectorId',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingActionId: 'string',
            dingConnectorId: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'string',
        };
    }
}
exports.CreateActionResponseBodyItem = CreateActionResponseBodyItem;
class CreateConnectorRequestConnectorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiDomain: 'apiDomain',
            apiSecret: 'apiSecret',
            appId: 'appId',
            authValueEnv: 'authValueEnv',
            description: 'description',
            domainEnv: 'domainEnv',
            iconMediaId: 'iconMediaId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
        };
    }
    static types() {
        return {
            apiDomain: 'string',
            apiSecret: 'string',
            appId: 'number',
            authValueEnv: 'boolean',
            description: 'string',
            domainEnv: 'boolean',
            iconMediaId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
        };
    }
}
exports.CreateConnectorRequestConnectorInfo = CreateConnectorRequestConnectorInfo;
class CreateConnectorResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateConnectorResponseBodyItem = CreateConnectorResponseBodyItem;
class CreateTriggerRequestTriggerInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            inputSchema: 'inputSchema',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            name: 'name',
        };
    }
    static types() {
        return {
            description: 'string',
            dingConnectorId: 'string',
            inputSchema: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            name: 'string',
        };
    }
}
exports.CreateTriggerRequestTriggerInfo = CreateTriggerRequestTriggerInfo;
class CreateTriggerResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            dingTriggerId: 'dingTriggerId',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            dingTriggerId: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateTriggerResponseBodyItem = CreateTriggerResponseBodyItem;
class PullDataByPageResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataCreateAppId: 'dataCreateAppId',
            dataCreateAppType: 'dataCreateAppType',
            dataGmtCreate: 'dataGmtCreate',
            dataGmtModified: 'dataGmtModified',
            dataModifiedAppId: 'dataModifiedAppId',
            dataModifiedAppType: 'dataModifiedAppType',
            jsonData: 'jsonData',
        };
    }
    static types() {
        return {
            dataCreateAppId: 'string',
            dataCreateAppType: 'string',
            dataGmtCreate: 'number',
            dataGmtModified: 'number',
            dataModifiedAppId: 'string',
            dataModifiedAppType: 'string',
            jsonData: 'string',
        };
    }
}
exports.PullDataByPageResponseBodyList = PullDataByPageResponseBodyList;
class SyncDataRequestTriggerDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            customTriggerId: 'customTriggerId',
            dataGmtCreate: 'dataGmtCreate',
            dataGmtModified: 'dataGmtModified',
            jsonData: 'jsonData',
            triggerId: 'triggerId',
        };
    }
    static types() {
        return {
            action: 'string',
            customTriggerId: 'string',
            dataGmtCreate: 'number',
            dataGmtModified: 'number',
            jsonData: 'string',
            triggerId: 'string',
        };
    }
}
exports.SyncDataRequestTriggerDataList = SyncDataRequestTriggerDataList;
class SyncDataResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizPrimaryKey: 'bizPrimaryKey',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
            triggerId: 'triggerId',
        };
    }
    static types() {
        return {
            bizPrimaryKey: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
            triggerId: 'string',
        };
    }
}
exports.SyncDataResponseBodyList = SyncDataResponseBodyList;
class UpdateActionRequestActionInfoInputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfoInputMappingConfig = UpdateActionRequestActionInfoInputMappingConfig;
class UpdateActionRequestActionInfoOutputDataRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expectValue: 'expectValue',
            operate: 'operate',
            propertyPath: 'propertyPath',
        };
    }
    static types() {
        return {
            expectValue: 'string',
            operate: 'string',
            propertyPath: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfoOutputDataRules = UpdateActionRequestActionInfoOutputDataRules;
class UpdateActionRequestActionInfoOutputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfoOutputMappingConfig = UpdateActionRequestActionInfoOutputMappingConfig;
class UpdateActionRequestActionInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiPath: 'apiPath',
            description: 'description',
            dingActionId: 'dingActionId',
            dingConnectorId: 'dingConnectorId',
            inputMappingConfig: 'inputMappingConfig',
            inputSchema: 'inputSchema',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
            outputDataRules: 'outputDataRules',
            outputMappingConfig: 'outputMappingConfig',
            outputSchema: 'outputSchema',
        };
    }
    static types() {
        return {
            apiPath: 'string',
            description: 'string',
            dingActionId: 'string',
            dingConnectorId: 'string',
            inputMappingConfig: UpdateActionRequestActionInfoInputMappingConfig,
            inputSchema: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
            outputDataRules: { 'type': 'array', 'itemType': UpdateActionRequestActionInfoOutputDataRules },
            outputMappingConfig: UpdateActionRequestActionInfoOutputMappingConfig,
            outputSchema: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfo = UpdateActionRequestActionInfo;
class UpdateActionResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingActionId: 'dingActionId',
            dingConnectorId: 'dingConnectorId',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingActionId: 'string',
            dingConnectorId: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'string',
        };
    }
}
exports.UpdateActionResponseBodyItem = UpdateActionResponseBodyItem;
class UpdateConnectorRequestConnectorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiDomain: 'apiDomain',
            apiSecret: 'apiSecret',
            appId: 'appId',
            authValueEnv: 'authValueEnv',
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            domainEnv: 'domainEnv',
            iconMediaId: 'iconMediaId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
        };
    }
    static types() {
        return {
            apiDomain: 'string',
            apiSecret: 'string',
            appId: 'number',
            authValueEnv: 'boolean',
            description: 'string',
            dingConnectorId: 'string',
            domainEnv: 'boolean',
            iconMediaId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
        };
    }
}
exports.UpdateConnectorRequestConnectorInfo = UpdateConnectorRequestConnectorInfo;
class UpdateConnectorResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateConnectorResponseBodyItem = UpdateConnectorResponseBodyItem;
class UpdateTriggerRequestTriggerInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            dingTriggerId: 'dingTriggerId',
            inputSchema: 'inputSchema',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            name: 'name',
        };
    }
    static types() {
        return {
            description: 'string',
            dingConnectorId: 'string',
            dingTriggerId: 'string',
            inputSchema: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            name: 'string',
        };
    }
}
exports.UpdateTriggerRequestTriggerInfo = UpdateTriggerRequestTriggerInfo;
class UpdateTriggerResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            dingTriggerId: 'dingTriggerId',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            dingTriggerId: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateTriggerResponseBodyItem = UpdateTriggerResponseBodyItem;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async createAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateActionHeaders({});
        return await this.createActionWithOptions(request, headers, runtime);
    }
    async createActionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.actionInfo)) {
            body["actionInfo"] = request.actionInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateAction", "connector_1.0", "HTTP", "POST", "AK", `/v1.0/connector/actions`, "json", req, runtime), new CreateActionResponse({}));
    }
    async createConnector(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateConnectorHeaders({});
        return await this.createConnectorWithOptions(request, headers, runtime);
    }
    async createConnectorWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectorInfo)) {
            body["connectorInfo"] = request.connectorInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateConnector", "connector_1.0", "HTTP", "POST", "AK", `/v1.0/connector/connectors`, "json", req, runtime), new CreateConnectorResponse({}));
    }
    async createTrigger(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateTriggerHeaders({});
        return await this.createTriggerWithOptions(request, headers, runtime);
    }
    async createTriggerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        if (!tea_util_1.default.isUnset(request.triggerInfo)) {
            body["triggerInfo"] = request.triggerInfo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateTrigger", "connector_1.0", "HTTP", "POST", "AK", `/v1.0/connector/triggers`, "json", req, runtime), new CreateTriggerResponse({}));
    }
    async pullDataByPage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PullDataByPageHeaders({});
        return await this.pullDataByPageWithOptions(request, headers, runtime);
    }
    async pullDataByPageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            query["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.dataModelId)) {
            query["dataModelId"] = request.dataModelId;
        }
        if (!tea_util_1.default.isUnset(request.datetimeFilterField)) {
            query["datetimeFilterField"] = request.datetimeFilterField;
        }
        if (!tea_util_1.default.isUnset(request.maxDatetime)) {
            query["maxDatetime"] = request.maxDatetime;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.minDatetime)) {
            query["minDatetime"] = request.minDatetime;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("PullDataByPage", "connector_1.0", "HTTP", "GET", "AK", `/v1.0/connector/data`, "json", req, runtime), new PullDataByPageResponse({}));
    }
    async pullDataByPk(dataModelId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PullDataByPkHeaders({});
        return await this.pullDataByPkWithOptions(dataModelId, request, headers, runtime);
    }
    async pullDataByPkWithOptions(dataModelId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        dataModelId = openapi_util_1.default.getEncodeParam(dataModelId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            query["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.primaryKey)) {
            query["primaryKey"] = request.primaryKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("PullDataByPk", "connector_1.0", "HTTP", "GET", "AK", `/v1.0/connector/data/${dataModelId}`, "json", req, runtime), new PullDataByPkResponse({}));
    }
    async syncData(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SyncDataHeaders({});
        return await this.syncDataWithOptions(request, headers, runtime);
    }
    async syncDataWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.triggerDataList)) {
            body["triggerDataList"] = request.triggerDataList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("SyncData", "connector_1.0", "HTTP", "POST", "AK", `/v1.0/connector/triggers/data/sync`, "json", req, runtime), new SyncDataResponse({}));
    }
    async updateAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateActionHeaders({});
        return await this.updateActionWithOptions(request, headers, runtime);
    }
    async updateActionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.actionInfo)) {
            body["actionInfo"] = request.actionInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateAction", "connector_1.0", "HTTP", "PUT", "AK", `/v1.0/connector/actions`, "json", req, runtime), new UpdateActionResponse({}));
    }
    async updateConnector(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateConnectorHeaders({});
        return await this.updateConnectorWithOptions(request, headers, runtime);
    }
    async updateConnectorWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectorInfo)) {
            body["connectorInfo"] = request.connectorInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateConnector", "connector_1.0", "HTTP", "PUT", "AK", `/v1.0/connector/connectors`, "json", req, runtime), new UpdateConnectorResponse({}));
    }
    async updateTrigger(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateTriggerHeaders({});
        return await this.updateTriggerWithOptions(request, headers, runtime);
    }
    async updateTriggerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        if (!tea_util_1.default.isUnset(request.triggerInfo)) {
            body["triggerInfo"] = request.triggerInfo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateTrigger", "connector_1.0", "HTTP", "PUT", "AK", `/v1.0/connector/triggers`, "json", req, runtime), new UpdateTriggerResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map