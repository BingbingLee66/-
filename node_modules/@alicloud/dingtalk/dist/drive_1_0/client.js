"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddCustomSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddCustomSpaceHeaders = AddCustomSpaceHeaders;
class AddCustomSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            identifier: 'identifier',
            permissionMode: 'permissionMode',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            identifier: 'string',
            permissionMode: 'string',
            unionId: 'string',
        };
    }
}
exports.AddCustomSpaceRequest = AddCustomSpaceRequest;
class AddCustomSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifyTime: 'modifyTime',
            permissionMode: 'permissionMode',
            quota: 'quota',
            spaceId: 'spaceId',
            spaceName: 'spaceName',
            spaceType: 'spaceType',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifyTime: 'string',
            permissionMode: 'string',
            quota: 'number',
            spaceId: 'string',
            spaceName: 'string',
            spaceType: 'string',
            usedQuota: 'number',
        };
    }
}
exports.AddCustomSpaceResponseBody = AddCustomSpaceResponseBody;
class AddCustomSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddCustomSpaceResponseBody,
        };
    }
}
exports.AddCustomSpaceResponse = AddCustomSpaceResponse;
class AddFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddFileHeaders = AddFileHeaders;
class AddFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addConflictPolicy: 'addConflictPolicy',
            fileName: 'fileName',
            fileType: 'fileType',
            mediaId: 'mediaId',
            parentId: 'parentId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            addConflictPolicy: 'string',
            fileName: 'string',
            fileType: 'string',
            mediaId: 'string',
            parentId: 'string',
            unionId: 'string',
        };
    }
}
exports.AddFileRequest = AddFileRequest;
class AddFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createTime: 'createTime',
            creator: 'creator',
            fileExtension: 'fileExtension',
            fileId: 'fileId',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            modifier: 'modifier',
            modifyTime: 'modifyTime',
            parentId: 'parentId',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createTime: 'string',
            creator: 'string',
            fileExtension: 'string',
            fileId: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            modifier: 'string',
            modifyTime: 'string',
            parentId: 'string',
            spaceId: 'string',
        };
    }
}
exports.AddFileResponseBody = AddFileResponseBody;
class AddFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddFileResponseBody,
        };
    }
}
exports.AddFileResponse = AddFileResponse;
class AddPermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddPermissionHeaders = AddPermissionHeaders;
class AddPermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            role: 'role',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': AddPermissionRequestMembers },
            role: 'string',
            unionId: 'string',
        };
    }
}
exports.AddPermissionRequest = AddPermissionRequest;
class AddPermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.AddPermissionResponse = AddPermissionResponse;
class AddSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddSpaceHeaders = AddSpaceHeaders;
class AddSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.AddSpaceRequest = AddSpaceRequest;
class AddSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifyTime: 'modifyTime',
            permissionMode: 'permissionMode',
            quota: 'quota',
            spaceId: 'spaceId',
            spaceName: 'spaceName',
            spaceType: 'spaceType',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifyTime: 'string',
            permissionMode: 'string',
            quota: 'number',
            spaceId: 'string',
            spaceName: 'string',
            spaceType: 'string',
            usedQuota: 'number',
        };
    }
}
exports.AddSpaceResponseBody = AddSpaceResponseBody;
class AddSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddSpaceResponseBody,
        };
    }
}
exports.AddSpaceResponse = AddSpaceResponse;
class ClearRecycleFilesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ClearRecycleFilesHeaders = ClearRecycleFilesHeaders;
class ClearRecycleFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleType: 'recycleType',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            recycleType: 'string',
            unionId: 'string',
        };
    }
}
exports.ClearRecycleFilesRequest = ClearRecycleFilesRequest;
class ClearRecycleFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.ClearRecycleFilesResponse = ClearRecycleFilesResponse;
class CopyFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CopyFileHeaders = CopyFileHeaders;
class CopyFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addConflictPolicy: 'addConflictPolicy',
            targetParentId: 'targetParentId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            addConflictPolicy: 'string',
            targetParentId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.CopyFileRequest = CopyFileRequest;
class CopyFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            file: 'file',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            file: CopyFileResponseBodyFile,
            taskId: 'string',
        };
    }
}
exports.CopyFileResponseBody = CopyFileResponseBody;
class CopyFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CopyFileResponseBody,
        };
    }
}
exports.CopyFileResponse = CopyFileResponse;
class DeleteFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteFileHeaders = DeleteFileHeaders;
class DeleteFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deletePolicy: 'deletePolicy',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            deletePolicy: 'string',
            unionId: 'string',
        };
    }
}
exports.DeleteFileRequest = DeleteFileRequest;
class DeleteFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeleteFileResponseBody = DeleteFileResponseBody;
class DeleteFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteFileResponseBody,
        };
    }
}
exports.DeleteFileResponse = DeleteFileResponse;
class DeleteFilesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteFilesHeaders = DeleteFilesHeaders;
class DeleteFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deletePolicy: 'deletePolicy',
            fileIds: 'fileIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            deletePolicy: 'string',
            fileIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.DeleteFilesRequest = DeleteFilesRequest;
class DeleteFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            success: 'boolean',
            taskId: 'string',
        };
    }
}
exports.DeleteFilesResponseBody = DeleteFilesResponseBody;
class DeleteFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteFilesResponseBody,
        };
    }
}
exports.DeleteFilesResponse = DeleteFilesResponse;
class DeletePermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeletePermissionHeaders = DeletePermissionHeaders;
class DeletePermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            role: 'role',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': DeletePermissionRequestMembers },
            role: 'string',
            unionId: 'string',
        };
    }
}
exports.DeletePermissionRequest = DeletePermissionRequest;
class DeletePermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.DeletePermissionResponse = DeletePermissionResponse;
class DeleteRecycleFilesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteRecycleFilesHeaders = DeleteRecycleFilesHeaders;
class DeleteRecycleFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleItemIdList: 'recycleItemIdList',
            recycleType: 'recycleType',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            recycleItemIdList: { 'type': 'array', 'itemType': 'number' },
            recycleType: 'string',
            unionId: 'string',
        };
    }
}
exports.DeleteRecycleFilesRequest = DeleteRecycleFilesRequest;
class DeleteRecycleFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.DeleteRecycleFilesResponse = DeleteRecycleFilesResponse;
class DeleteSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteSpaceHeaders = DeleteSpaceHeaders;
class DeleteSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.DeleteSpaceRequest = DeleteSpaceRequest;
class DeleteSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.DeleteSpaceResponse = DeleteSpaceResponse;
class GetAsyncTaskInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetAsyncTaskInfoHeaders = GetAsyncTaskInfoHeaders;
class GetAsyncTaskInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetAsyncTaskInfoRequest = GetAsyncTaskInfoRequest;
class GetAsyncTaskInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            beginTime: 'beginTime',
            endTime: 'endTime',
            failed: 'failed',
            status: 'status',
            success: 'success',
            taskId: 'taskId',
            total: 'total',
        };
    }
    static types() {
        return {
            beginTime: 'string',
            endTime: 'string',
            failed: 'number',
            status: 'string',
            success: 'number',
            taskId: 'string',
            total: 'number',
        };
    }
}
exports.GetAsyncTaskInfoResponseBody = GetAsyncTaskInfoResponseBody;
class GetAsyncTaskInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetAsyncTaskInfoResponseBody,
        };
    }
}
exports.GetAsyncTaskInfoResponse = GetAsyncTaskInfoResponse;
class GetDownloadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetDownloadInfoHeaders = GetDownloadInfoHeaders;
class GetDownloadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
            withInternalResourceUrl: 'withInternalResourceUrl',
            withRegion: 'withRegion',
        };
    }
    static types() {
        return {
            unionId: 'string',
            withInternalResourceUrl: 'boolean',
            withRegion: 'boolean',
        };
    }
}
exports.GetDownloadInfoRequest = GetDownloadInfoRequest;
class GetDownloadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadInfo: 'downloadInfo',
            region: 'region',
        };
    }
    static types() {
        return {
            downloadInfo: GetDownloadInfoResponseBodyDownloadInfo,
            region: 'string',
        };
    }
}
exports.GetDownloadInfoResponseBody = GetDownloadInfoResponseBody;
class GetDownloadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetDownloadInfoResponseBody,
        };
    }
}
exports.GetDownloadInfoResponse = GetDownloadInfoResponse;
class GetFileInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileInfoHeaders = GetFileInfoHeaders;
class GetFileInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetFileInfoRequest = GetFileInfoRequest;
class GetFileInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createTime: 'createTime',
            creator: 'creator',
            fileExtension: 'fileExtension',
            fileId: 'fileId',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            modifier: 'modifier',
            modifyTime: 'modifyTime',
            parentId: 'parentId',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createTime: 'string',
            creator: 'string',
            fileExtension: 'string',
            fileId: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            modifier: 'string',
            modifyTime: 'string',
            parentId: 'string',
            spaceId: 'string',
        };
    }
}
exports.GetFileInfoResponseBody = GetFileInfoResponseBody;
class GetFileInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetFileInfoResponseBody,
        };
    }
}
exports.GetFileInfoResponse = GetFileInfoResponse;
class GetMySpaceInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetMySpaceInfoHeaders = GetMySpaceInfoHeaders;
class GetMySpaceInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetMySpaceInfoRequest = GetMySpaceInfoRequest;
class GetMySpaceInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifyTime: 'modifyTime',
            permissionMode: 'permissionMode',
            quota: 'quota',
            spaceId: 'spaceId',
            spaceName: 'spaceName',
            spaceType: 'spaceType',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifyTime: 'string',
            permissionMode: 'string',
            quota: 'number',
            spaceId: 'string',
            spaceName: 'string',
            spaceType: 'string',
            usedQuota: 'number',
        };
    }
}
exports.GetMySpaceInfoResponseBody = GetMySpaceInfoResponseBody;
class GetMySpaceInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetMySpaceInfoResponseBody,
        };
    }
}
exports.GetMySpaceInfoResponse = GetMySpaceInfoResponse;
class GetPreviewInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetPreviewInfoHeaders = GetPreviewInfoHeaders;
class GetPreviewInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetPreviewInfoRequest = GetPreviewInfoRequest;
class GetPreviewInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            info: 'info',
        };
    }
    static types() {
        return {
            info: GetPreviewInfoResponseBodyInfo,
        };
    }
}
exports.GetPreviewInfoResponseBody = GetPreviewInfoResponseBody;
class GetPreviewInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetPreviewInfoResponseBody,
        };
    }
}
exports.GetPreviewInfoResponse = GetPreviewInfoResponse;
class GetPrivilegeInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetPrivilegeInfoHeaders = GetPrivilegeInfoHeaders;
class GetPrivilegeInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetPrivilegeInfoRequest = GetPrivilegeInfoRequest;
class GetPrivilegeInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            types: 'types',
        };
    }
    static types() {
        return {
            types: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetPrivilegeInfoResponseBody = GetPrivilegeInfoResponseBody;
class GetPrivilegeInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetPrivilegeInfoResponseBody,
        };
    }
}
exports.GetPrivilegeInfoResponse = GetPrivilegeInfoResponse;
class GetQuotaInfosHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetQuotaInfosHeaders = GetQuotaInfosHeaders;
class GetQuotaInfosRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            identifiers: 'identifiers',
            type: 'type',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            identifiers: { 'type': 'array', 'itemType': 'string' },
            type: 'string',
            unionId: 'string',
        };
    }
}
exports.GetQuotaInfosRequest = GetQuotaInfosRequest;
class GetQuotaInfosResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            quotas: 'quotas',
        };
    }
    static types() {
        return {
            quotas: { 'type': 'array', 'itemType': GetQuotaInfosResponseBodyQuotas },
        };
    }
}
exports.GetQuotaInfosResponseBody = GetQuotaInfosResponseBody;
class GetQuotaInfosResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetQuotaInfosResponseBody,
        };
    }
}
exports.GetQuotaInfosResponse = GetQuotaInfosResponse;
class GetUploadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetUploadInfoHeaders = GetUploadInfoHeaders;
class GetUploadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addConflictPolicy: 'addConflictPolicy',
            callerRegion: 'callerRegion',
            fileName: 'fileName',
            fileSize: 'fileSize',
            md5: 'md5',
            mediaId: 'mediaId',
            unionId: 'unionId',
            withInternalEndPoint: 'withInternalEndPoint',
            withRegion: 'withRegion',
        };
    }
    static types() {
        return {
            addConflictPolicy: 'string',
            callerRegion: 'string',
            fileName: 'string',
            fileSize: 'number',
            md5: 'string',
            mediaId: 'string',
            unionId: 'string',
            withInternalEndPoint: 'boolean',
            withRegion: 'boolean',
        };
    }
}
exports.GetUploadInfoRequest = GetUploadInfoRequest;
class GetUploadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headerSignatureUploadInfo: 'headerSignatureUploadInfo',
            region: 'region',
            stsUploadInfo: 'stsUploadInfo',
        };
    }
    static types() {
        return {
            headerSignatureUploadInfo: GetUploadInfoResponseBodyHeaderSignatureUploadInfo,
            region: 'string',
            stsUploadInfo: GetUploadInfoResponseBodyStsUploadInfo,
        };
    }
}
exports.GetUploadInfoResponseBody = GetUploadInfoResponseBody;
class GetUploadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetUploadInfoResponseBody,
        };
    }
}
exports.GetUploadInfoResponse = GetUploadInfoResponse;
class GrantPrivilegeOfCustomSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GrantPrivilegeOfCustomSpaceHeaders = GrantPrivilegeOfCustomSpaceHeaders;
class GrantPrivilegeOfCustomSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            fileIds: 'fileIds',
            type: 'type',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            duration: 'number',
            fileIds: { 'type': 'array', 'itemType': 'string' },
            type: 'string',
            unionId: 'string',
            userId: 'string',
        };
    }
}
exports.GrantPrivilegeOfCustomSpaceRequest = GrantPrivilegeOfCustomSpaceRequest;
class GrantPrivilegeOfCustomSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.GrantPrivilegeOfCustomSpaceResponse = GrantPrivilegeOfCustomSpaceResponse;
class InfoSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.InfoSpaceHeaders = InfoSpaceHeaders;
class InfoSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.InfoSpaceRequest = InfoSpaceRequest;
class InfoSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifyTime: 'modifyTime',
            permissionMode: 'permissionMode',
            quota: 'quota',
            spaceId: 'spaceId',
            spaceName: 'spaceName',
            spaceType: 'spaceType',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifyTime: 'string',
            permissionMode: 'string',
            quota: 'number',
            spaceId: 'string',
            spaceName: 'string',
            spaceType: 'string',
            usedQuota: 'number',
        };
    }
}
exports.InfoSpaceResponseBody = InfoSpaceResponseBody;
class InfoSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: InfoSpaceResponseBody,
        };
    }
}
exports.InfoSpaceResponse = InfoSpaceResponse;
class ListFilesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListFilesHeaders = ListFilesHeaders;
class ListFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            orderType: 'orderType',
            parentId: 'parentId',
            unionId: 'unionId',
            withIcon: 'withIcon',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            orderType: 'string',
            parentId: 'string',
            unionId: 'string',
            withIcon: 'boolean',
        };
    }
}
exports.ListFilesRequest = ListFilesRequest;
class ListFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            files: 'files',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            files: { 'type': 'array', 'itemType': ListFilesResponseBodyFiles },
            nextToken: 'string',
        };
    }
}
exports.ListFilesResponseBody = ListFilesResponseBody;
class ListFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListFilesResponseBody,
        };
    }
}
exports.ListFilesResponse = ListFilesResponse;
class ListPermissionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListPermissionsHeaders = ListPermissionsHeaders;
class ListPermissionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.ListPermissionsRequest = ListPermissionsRequest;
class ListPermissionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            outMembers: 'outMembers',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': ListPermissionsResponseBodyMembers },
            outMembers: { 'type': 'array', 'itemType': ListPermissionsResponseBodyOutMembers },
        };
    }
}
exports.ListPermissionsResponseBody = ListPermissionsResponseBody;
class ListPermissionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListPermissionsResponseBody,
        };
    }
}
exports.ListPermissionsResponse = ListPermissionsResponse;
class ListRecycleFilesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListRecycleFilesHeaders = ListRecycleFilesHeaders;
class ListRecycleFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            orderType: 'orderType',
            recycleType: 'recycleType',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            orderType: 'string',
            recycleType: 'string',
            unionId: 'string',
        };
    }
}
exports.ListRecycleFilesRequest = ListRecycleFilesRequest;
class ListRecycleFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            recycleItems: 'recycleItems',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            recycleItems: { 'type': 'array', 'itemType': ListRecycleFilesResponseBodyRecycleItems },
        };
    }
}
exports.ListRecycleFilesResponseBody = ListRecycleFilesResponseBody;
class ListRecycleFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListRecycleFilesResponseBody,
        };
    }
}
exports.ListRecycleFilesResponse = ListRecycleFilesResponse;
class ListSpacesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListSpacesHeaders = ListSpacesHeaders;
class ListSpacesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            spaceType: 'spaceType',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            spaceType: 'string',
            unionId: 'string',
        };
    }
}
exports.ListSpacesRequest = ListSpacesRequest;
class ListSpacesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            spaces: 'spaces',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            spaces: { 'type': 'array', 'itemType': ListSpacesResponseBodySpaces },
        };
    }
}
exports.ListSpacesResponseBody = ListSpacesResponseBody;
class ListSpacesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListSpacesResponseBody,
        };
    }
}
exports.ListSpacesResponse = ListSpacesResponse;
class ManagementBuyQuotaHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ManagementBuyQuotaHeaders = ManagementBuyQuotaHeaders;
class ManagementBuyQuotaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            order: 'order',
            token: 'token',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            order: ManagementBuyQuotaRequestOrder,
            token: 'string',
            unionId: 'string',
        };
    }
}
exports.ManagementBuyQuotaRequest = ManagementBuyQuotaRequest;
class ManagementBuyQuotaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.ManagementBuyQuotaResponse = ManagementBuyQuotaResponse;
class ManagementListSpacesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ManagementListSpacesHeaders = ManagementListSpacesHeaders;
class ManagementListSpacesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            spaceIds: 'spaceIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            spaceIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.ManagementListSpacesRequest = ManagementListSpacesRequest;
class ManagementListSpacesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            spaces: 'spaces',
        };
    }
    static types() {
        return {
            spaces: { 'type': 'array', 'itemType': ManagementListSpacesResponseBodySpaces },
        };
    }
}
exports.ManagementListSpacesResponseBody = ManagementListSpacesResponseBody;
class ManagementListSpacesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ManagementListSpacesResponseBody,
        };
    }
}
exports.ManagementListSpacesResponse = ManagementListSpacesResponse;
class ManagementModifySpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ManagementModifySpaceHeaders = ManagementModifySpaceHeaders;
class ManagementModifySpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            quota: 'quota',
            spaceIds: 'spaceIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            quota: 'number',
            spaceIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.ManagementModifySpaceRequest = ManagementModifySpaceRequest;
class ManagementModifySpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            spaces: 'spaces',
        };
    }
    static types() {
        return {
            spaces: { 'type': 'array', 'itemType': ManagementModifySpaceResponseBodySpaces },
        };
    }
}
exports.ManagementModifySpaceResponseBody = ManagementModifySpaceResponseBody;
class ManagementModifySpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ManagementModifySpaceResponseBody,
        };
    }
}
exports.ManagementModifySpaceResponse = ManagementModifySpaceResponse;
class ModifyPermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ModifyPermissionHeaders = ModifyPermissionHeaders;
class ModifyPermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            role: 'role',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': ModifyPermissionRequestMembers },
            role: 'string',
            unionId: 'string',
        };
    }
}
exports.ModifyPermissionRequest = ModifyPermissionRequest;
class ModifyPermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.ModifyPermissionResponse = ModifyPermissionResponse;
class MoveFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MoveFileHeaders = MoveFileHeaders;
class MoveFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addConflictPolicy: 'addConflictPolicy',
            targetParentId: 'targetParentId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            addConflictPolicy: 'string',
            targetParentId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.MoveFileRequest = MoveFileRequest;
class MoveFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createTime: 'createTime',
            creator: 'creator',
            fileExtension: 'fileExtension',
            fileId: 'fileId',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            modifier: 'modifier',
            modifyTime: 'modifyTime',
            parentId: 'parentId',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createTime: 'string',
            creator: 'string',
            fileExtension: 'string',
            fileId: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            modifier: 'string',
            modifyTime: 'string',
            parentId: 'string',
            spaceId: 'string',
        };
    }
}
exports.MoveFileResponseBody = MoveFileResponseBody;
class MoveFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: MoveFileResponseBody,
        };
    }
}
exports.MoveFileResponse = MoveFileResponse;
class MoveFilesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MoveFilesHeaders = MoveFilesHeaders;
class MoveFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            addConflictPolicy: 'addConflictPolicy',
            fileIds: 'fileIds',
            targetParentId: 'targetParentId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            addConflictPolicy: 'string',
            fileIds: { 'type': 'array', 'itemType': 'string' },
            targetParentId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.MoveFilesRequest = MoveFilesRequest;
class MoveFilesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            files: 'files',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            files: { 'type': 'array', 'itemType': MoveFilesResponseBodyFiles },
            taskId: 'string',
        };
    }
}
exports.MoveFilesResponseBody = MoveFilesResponseBody;
class MoveFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: MoveFilesResponseBody,
        };
    }
}
exports.MoveFilesResponse = MoveFilesResponse;
class RecoverRecycleFilesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RecoverRecycleFilesHeaders = RecoverRecycleFilesHeaders;
class RecoverRecycleFilesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleItemIdList: 'recycleItemIdList',
            recycleType: 'recycleType',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            recycleItemIdList: { 'type': 'array', 'itemType': 'number' },
            recycleType: 'string',
            unionId: 'string',
        };
    }
}
exports.RecoverRecycleFilesRequest = RecoverRecycleFilesRequest;
class RecoverRecycleFilesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.RecoverRecycleFilesResponse = RecoverRecycleFilesResponse;
class RenameFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RenameFileHeaders = RenameFileHeaders;
class RenameFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            newFileName: 'newFileName',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            newFileName: 'string',
            unionId: 'string',
        };
    }
}
exports.RenameFileRequest = RenameFileRequest;
class RenameFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createTime: 'createTime',
            creator: 'creator',
            fileExtension: 'fileExtension',
            fileId: 'fileId',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            modifier: 'modifier',
            modifyTime: 'modifyTime',
            parentId: 'parentId',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createTime: 'string',
            creator: 'string',
            fileExtension: 'string',
            fileId: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            modifier: 'string',
            modifyTime: 'string',
            parentId: 'string',
            spaceId: 'string',
        };
    }
}
exports.RenameFileResponseBody = RenameFileResponseBody;
class RenameFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: RenameFileResponseBody,
        };
    }
}
exports.RenameFileResponse = RenameFileResponse;
class AddPermissionRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            memberId: 'memberId',
            memberType: 'memberType',
        };
    }
    static types() {
        return {
            corpId: 'string',
            memberId: 'string',
            memberType: 'string',
        };
    }
}
exports.AddPermissionRequestMembers = AddPermissionRequestMembers;
class CopyFileResponseBodyFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createTime: 'createTime',
            creator: 'creator',
            fileExtension: 'fileExtension',
            fileId: 'fileId',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            modifier: 'modifier',
            modifyTime: 'modifyTime',
            parentId: 'parentId',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createTime: 'string',
            creator: 'string',
            fileExtension: 'string',
            fileId: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            modifier: 'string',
            modifyTime: 'string',
            parentId: 'string',
            spaceId: 'string',
        };
    }
}
exports.CopyFileResponseBodyFile = CopyFileResponseBodyFile;
class DeletePermissionRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            memberId: 'memberId',
            memberType: 'memberType',
        };
    }
    static types() {
        return {
            corpId: 'string',
            memberId: 'string',
            memberType: 'string',
        };
    }
}
exports.DeletePermissionRequestMembers = DeletePermissionRequestMembers;
class GetDownloadInfoResponseBodyDownloadInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationSeconds: 'expirationSeconds',
            headers: 'headers',
            internalResourceUrl: 'internalResourceUrl',
            resourceUrl: 'resourceUrl',
        };
    }
    static types() {
        return {
            expirationSeconds: 'number',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            internalResourceUrl: 'string',
            resourceUrl: 'string',
        };
    }
}
exports.GetDownloadInfoResponseBodyDownloadInfo = GetDownloadInfoResponseBodyDownloadInfo;
class GetPreviewInfoResponseBodyInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.GetPreviewInfoResponseBodyInfo = GetPreviewInfoResponseBodyInfo;
class GetQuotaInfosResponseBodyQuotas extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            identifier: 'identifier',
            quota: 'quota',
            type: 'type',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            identifier: 'string',
            quota: 'number',
            type: 'string',
            usedQuota: 'number',
        };
    }
}
exports.GetQuotaInfosResponseBodyQuotas = GetQuotaInfosResponseBodyQuotas;
class GetUploadInfoResponseBodyHeaderSignatureUploadInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationSeconds: 'expirationSeconds',
            headers: 'headers',
            internalResourceUrl: 'internalResourceUrl',
            mediaId: 'mediaId',
            resourceUrl: 'resourceUrl',
        };
    }
    static types() {
        return {
            expirationSeconds: 'number',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            internalResourceUrl: 'string',
            mediaId: 'string',
            resourceUrl: 'string',
        };
    }
}
exports.GetUploadInfoResponseBodyHeaderSignatureUploadInfo = GetUploadInfoResponseBodyHeaderSignatureUploadInfo;
class GetUploadInfoResponseBodyStsUploadInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accessKeyId: 'accessKeyId',
            accessKeySecret: 'accessKeySecret',
            accessToken: 'accessToken',
            accessTokenExpirationMillis: 'accessTokenExpirationMillis',
            bucket: 'bucket',
            endPoint: 'endPoint',
            internalEndPoint: 'internalEndPoint',
            mediaId: 'mediaId',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            accessKeySecret: 'string',
            accessToken: 'string',
            accessTokenExpirationMillis: 'number',
            bucket: 'string',
            endPoint: 'string',
            internalEndPoint: 'string',
            mediaId: 'string',
        };
    }
}
exports.GetUploadInfoResponseBodyStsUploadInfo = GetUploadInfoResponseBodyStsUploadInfo;
class ListFilesResponseBodyFiles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createTime: 'createTime',
            creator: 'creator',
            fileExtension: 'fileExtension',
            fileId: 'fileId',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            icon: 'icon',
            modifier: 'modifier',
            modifyTime: 'modifyTime',
            parentId: 'parentId',
            spaceId: 'spaceId',
            thumbnail: 'thumbnail',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createTime: 'string',
            creator: 'string',
            fileExtension: 'string',
            fileId: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            icon: 'string',
            modifier: 'string',
            modifyTime: 'string',
            parentId: 'string',
            spaceId: 'string',
            thumbnail: 'string',
        };
    }
}
exports.ListFilesResponseBodyFiles = ListFilesResponseBodyFiles;
class ListPermissionsResponseBodyMembersMember extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            memberId: 'memberId',
            memberName: 'memberName',
            memberType: 'memberType',
        };
    }
    static types() {
        return {
            corpId: 'string',
            memberId: 'string',
            memberName: 'string',
            memberType: 'string',
        };
    }
}
exports.ListPermissionsResponseBodyMembersMember = ListPermissionsResponseBodyMembersMember;
class ListPermissionsResponseBodyMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extend: 'extend',
            member: 'member',
            role: 'role',
        };
    }
    static types() {
        return {
            extend: 'boolean',
            member: ListPermissionsResponseBodyMembersMember,
            role: 'string',
        };
    }
}
exports.ListPermissionsResponseBodyMembers = ListPermissionsResponseBodyMembers;
class ListPermissionsResponseBodyOutMembersMember extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            memberId: 'memberId',
            memberName: 'memberName',
            memberType: 'memberType',
        };
    }
    static types() {
        return {
            corpId: 'string',
            memberId: 'string',
            memberName: 'string',
            memberType: 'string',
        };
    }
}
exports.ListPermissionsResponseBodyOutMembersMember = ListPermissionsResponseBodyOutMembersMember;
class ListPermissionsResponseBodyOutMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extend: 'extend',
            member: 'member',
            role: 'role',
        };
    }
    static types() {
        return {
            extend: 'boolean',
            member: ListPermissionsResponseBodyOutMembersMember,
            role: 'string',
        };
    }
}
exports.ListPermissionsResponseBodyOutMembers = ListPermissionsResponseBodyOutMembers;
class ListRecycleFilesResponseBodyRecycleItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            deleteStaffId: 'deleteStaffId',
            deleteTime: 'deleteTime',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            recycleItemId: 'recycleItemId',
        };
    }
    static types() {
        return {
            contentType: 'string',
            deleteStaffId: 'string',
            deleteTime: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            recycleItemId: 'string',
        };
    }
}
exports.ListRecycleFilesResponseBodyRecycleItems = ListRecycleFilesResponseBodyRecycleItems;
class ListSpacesResponseBodySpaces extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifyTime: 'modifyTime',
            permissionMode: 'permissionMode',
            quota: 'quota',
            spaceId: 'spaceId',
            spaceName: 'spaceName',
            spaceType: 'spaceType',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifyTime: 'string',
            permissionMode: 'string',
            quota: 'number',
            spaceId: 'string',
            spaceName: 'string',
            spaceType: 'string',
            usedQuota: 'number',
        };
    }
}
exports.ListSpacesResponseBodySpaces = ListSpacesResponseBodySpaces;
class ManagementBuyQuotaRequestOrder extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            capacity: 'capacity',
            capacityType: 'capacityType',
            day: 'day',
            money: 'money',
            orderId: 'orderId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            capacity: 'number',
            capacityType: 'string',
            day: 'number',
            money: 'number',
            orderId: 'number',
        };
    }
}
exports.ManagementBuyQuotaRequestOrder = ManagementBuyQuotaRequestOrder;
class ManagementListSpacesResponseBodySpaces extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifyTime: 'modifyTime',
            permissionMode: 'permissionMode',
            quota: 'quota',
            spaceId: 'spaceId',
            spaceName: 'spaceName',
            spaceType: 'spaceType',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifyTime: 'string',
            permissionMode: 'string',
            quota: 'number',
            spaceId: 'string',
            spaceName: 'string',
            spaceType: 'string',
            usedQuota: 'number',
        };
    }
}
exports.ManagementListSpacesResponseBodySpaces = ManagementListSpacesResponseBodySpaces;
class ManagementModifySpaceResponseBodySpaces extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifyTime: 'modifyTime',
            permissionMode: 'permissionMode',
            quota: 'quota',
            spaceId: 'spaceId',
            spaceName: 'spaceName',
            spaceType: 'spaceType',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifyTime: 'string',
            permissionMode: 'string',
            quota: 'number',
            spaceId: 'string',
            spaceName: 'string',
            spaceType: 'string',
            usedQuota: 'number',
        };
    }
}
exports.ManagementModifySpaceResponseBodySpaces = ManagementModifySpaceResponseBodySpaces;
class ModifyPermissionRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            memberId: 'memberId',
            memberType: 'memberType',
        };
    }
    static types() {
        return {
            corpId: 'string',
            memberId: 'string',
            memberType: 'string',
        };
    }
}
exports.ModifyPermissionRequestMembers = ModifyPermissionRequestMembers;
class MoveFilesResponseBodyFiles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createTime: 'createTime',
            creator: 'creator',
            fileExtension: 'fileExtension',
            fileId: 'fileId',
            fileName: 'fileName',
            filePath: 'filePath',
            fileSize: 'fileSize',
            fileType: 'fileType',
            modifier: 'modifier',
            modifyTime: 'modifyTime',
            parentId: 'parentId',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createTime: 'string',
            creator: 'string',
            fileExtension: 'string',
            fileId: 'string',
            fileName: 'string',
            filePath: 'string',
            fileSize: 'number',
            fileType: 'string',
            modifier: 'string',
            modifyTime: 'string',
            parentId: 'string',
            spaceId: 'string',
        };
    }
}
exports.MoveFilesResponseBodyFiles = MoveFilesResponseBodyFiles;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addCustomSpace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddCustomSpaceHeaders({});
        return await this.addCustomSpaceWithOptions(request, headers, runtime);
    }
    async addCustomSpaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            body["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.identifier)) {
            body["identifier"] = request.identifier;
        }
        if (!tea_util_1.default.isUnset(request.permissionMode)) {
            body["permissionMode"] = request.permissionMode;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddCustomSpace", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/customSpaces`, "json", req, runtime), new AddCustomSpaceResponse({}));
    }
    async addFile(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddFileHeaders({});
        return await this.addFileWithOptions(spaceId, request, headers, runtime);
    }
    async addFileWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.addConflictPolicy)) {
            body["addConflictPolicy"] = request.addConflictPolicy;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            body["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.fileType)) {
            body["fileType"] = request.fileType;
        }
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            body["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.parentId)) {
            body["parentId"] = request.parentId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddFile", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files`, "json", req, runtime), new AddFileResponse({}));
    }
    async addPermission(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddPermissionHeaders({});
        return await this.addPermissionWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async addPermissionWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddPermission", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/permissions`, "none", req, runtime), new AddPermissionResponse({}));
    }
    async addSpace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddSpaceHeaders({});
        return await this.addSpaceWithOptions(request, headers, runtime);
    }
    async addSpaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddSpace", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces`, "json", req, runtime), new AddSpaceResponse({}));
    }
    async clearRecycleFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ClearRecycleFilesHeaders({});
        return await this.clearRecycleFilesWithOptions(request, headers, runtime);
    }
    async clearRecycleFilesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.recycleType)) {
            body["recycleType"] = request.recycleType;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ClearRecycleFiles", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/recycleItems/clear`, "none", req, runtime), new ClearRecycleFilesResponse({}));
    }
    async copyFile(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CopyFileHeaders({});
        return await this.copyFileWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async copyFileWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.addConflictPolicy)) {
            body["addConflictPolicy"] = request.addConflictPolicy;
        }
        if (!tea_util_1.default.isUnset(request.targetParentId)) {
            body["targetParentId"] = request.targetParentId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CopyFile", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/copy`, "json", req, runtime), new CopyFileResponse({}));
    }
    async deleteFile(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteFileHeaders({});
        return await this.deleteFileWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async deleteFileWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.deletePolicy)) {
            query["deletePolicy"] = request.deletePolicy;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("DeleteFile", "drive_1.0", "HTTP", "DELETE", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}`, "json", req, runtime), new DeleteFileResponse({}));
    }
    async deleteFiles(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteFilesHeaders({});
        return await this.deleteFilesWithOptions(spaceId, request, headers, runtime);
    }
    async deleteFilesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deletePolicy)) {
            body["deletePolicy"] = request.deletePolicy;
        }
        if (!tea_util_1.default.isUnset(request.fileIds)) {
            body["fileIds"] = request.fileIds;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("DeleteFiles", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/batchDelete`, "json", req, runtime), new DeleteFilesResponse({}));
    }
    async deletePermission(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeletePermissionHeaders({});
        return await this.deletePermissionWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async deletePermissionWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("DeletePermission", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/permissions/delete`, "none", req, runtime), new DeletePermissionResponse({}));
    }
    async deleteRecycleFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRecycleFilesHeaders({});
        return await this.deleteRecycleFilesWithOptions(request, headers, runtime);
    }
    async deleteRecycleFilesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.recycleItemIdList)) {
            body["recycleItemIdList"] = request.recycleItemIdList;
        }
        if (!tea_util_1.default.isUnset(request.recycleType)) {
            body["recycleType"] = request.recycleType;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("DeleteRecycleFiles", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/recycleItems/delete`, "none", req, runtime), new DeleteRecycleFilesResponse({}));
    }
    async deleteSpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteSpaceHeaders({});
        return await this.deleteSpaceWithOptions(spaceId, request, headers, runtime);
    }
    async deleteSpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("DeleteSpace", "drive_1.0", "HTTP", "DELETE", "AK", `/v1.0/drive/spaces/${spaceId}`, "none", req, runtime), new DeleteSpaceResponse({}));
    }
    async getAsyncTaskInfo(taskId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAsyncTaskInfoHeaders({});
        return await this.getAsyncTaskInfoWithOptions(taskId, request, headers, runtime);
    }
    async getAsyncTaskInfoWithOptions(taskId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        taskId = openapi_util_1.default.getEncodeParam(taskId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetAsyncTaskInfo", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/tasks/${taskId}`, "json", req, runtime), new GetAsyncTaskInfoResponse({}));
    }
    async getDownloadInfo(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDownloadInfoHeaders({});
        return await this.getDownloadInfoWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async getDownloadInfoWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        if (!tea_util_1.default.isUnset(request.withInternalResourceUrl)) {
            query["withInternalResourceUrl"] = request.withInternalResourceUrl;
        }
        if (!tea_util_1.default.isUnset(request.withRegion)) {
            query["withRegion"] = request.withRegion;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetDownloadInfo", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/downloadInfos`, "json", req, runtime), new GetDownloadInfoResponse({}));
    }
    async getFileInfo(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileInfoHeaders({});
        return await this.getFileInfoWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async getFileInfoWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetFileInfo", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}`, "json", req, runtime), new GetFileInfoResponse({}));
    }
    async getMySpaceInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetMySpaceInfoHeaders({});
        return await this.getMySpaceInfoWithOptions(request, headers, runtime);
    }
    async getMySpaceInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetMySpaceInfo", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/mySpaces`, "json", req, runtime), new GetMySpaceInfoResponse({}));
    }
    async getPreviewInfo(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetPreviewInfoHeaders({});
        return await this.getPreviewInfoWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async getPreviewInfoWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetPreviewInfo", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/previewInfos`, "json", req, runtime), new GetPreviewInfoResponse({}));
    }
    async getPrivilegeInfo(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetPrivilegeInfoHeaders({});
        return await this.getPrivilegeInfoWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async getPrivilegeInfoWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetPrivilegeInfo", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/privileges`, "json", req, runtime), new GetPrivilegeInfoResponse({}));
    }
    async getQuotaInfos(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetQuotaInfosHeaders({});
        return await this.getQuotaInfosWithOptions(request, headers, runtime);
    }
    async getQuotaInfosWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.identifiers)) {
            body["identifiers"] = request.identifiers;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GetQuotaInfos", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/quotaInfos/query`, "json", req, runtime), new GetQuotaInfosResponse({}));
    }
    async getUploadInfo(spaceId, parentId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUploadInfoHeaders({});
        return await this.getUploadInfoWithOptions(spaceId, parentId, request, headers, runtime);
    }
    async getUploadInfoWithOptions(spaceId, parentId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        parentId = openapi_util_1.default.getEncodeParam(parentId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.addConflictPolicy)) {
            query["addConflictPolicy"] = request.addConflictPolicy;
        }
        if (!tea_util_1.default.isUnset(request.callerRegion)) {
            query["callerRegion"] = request.callerRegion;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.fileSize)) {
            query["fileSize"] = request.fileSize;
        }
        if (!tea_util_1.default.isUnset(request.md5)) {
            query["md5"] = request.md5;
        }
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            query["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        if (!tea_util_1.default.isUnset(request.withInternalEndPoint)) {
            query["withInternalEndPoint"] = request.withInternalEndPoint;
        }
        if (!tea_util_1.default.isUnset(request.withRegion)) {
            query["withRegion"] = request.withRegion;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetUploadInfo", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}/files/${parentId}/uploadInfos`, "json", req, runtime), new GetUploadInfoResponse({}));
    }
    async grantPrivilegeOfCustomSpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GrantPrivilegeOfCustomSpaceHeaders({});
        return await this.grantPrivilegeOfCustomSpaceWithOptions(spaceId, request, headers, runtime);
    }
    async grantPrivilegeOfCustomSpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.duration)) {
            body["duration"] = request.duration;
        }
        if (!tea_util_1.default.isUnset(request.fileIds)) {
            body["fileIds"] = request.fileIds;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GrantPrivilegeOfCustomSpace", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/customSpacePrivileges`, "none", req, runtime), new GrantPrivilegeOfCustomSpaceResponse({}));
    }
    async infoSpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InfoSpaceHeaders({});
        return await this.infoSpaceWithOptions(spaceId, request, headers, runtime);
    }
    async infoSpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("InfoSpace", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}`, "json", req, runtime), new InfoSpaceResponse({}));
    }
    async listFiles(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListFilesHeaders({});
        return await this.listFilesWithOptions(spaceId, request, headers, runtime);
    }
    async listFilesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["orderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.parentId)) {
            query["parentId"] = request.parentId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        if (!tea_util_1.default.isUnset(request.withIcon)) {
            query["withIcon"] = request.withIcon;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListFiles", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}/files`, "json", req, runtime), new ListFilesResponse({}));
    }
    async listPermissions(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListPermissionsHeaders({});
        return await this.listPermissionsWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async listPermissionsWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListPermissions", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/permissions`, "json", req, runtime), new ListPermissionsResponse({}));
    }
    async listRecycleFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListRecycleFilesHeaders({});
        return await this.listRecycleFilesWithOptions(request, headers, runtime);
    }
    async listRecycleFilesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.orderType)) {
            query["orderType"] = request.orderType;
        }
        if (!tea_util_1.default.isUnset(request.recycleType)) {
            query["recycleType"] = request.recycleType;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListRecycleFiles", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/recycleItems`, "json", req, runtime), new ListRecycleFilesResponse({}));
    }
    async listSpaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListSpacesHeaders({});
        return await this.listSpacesWithOptions(request, headers, runtime);
    }
    async listSpacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.spaceType)) {
            query["spaceType"] = request.spaceType;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListSpaces", "drive_1.0", "HTTP", "GET", "AK", `/v1.0/drive/spaces`, "json", req, runtime), new ListSpacesResponse({}));
    }
    async managementBuyQuota(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ManagementBuyQuotaHeaders({});
        return await this.managementBuyQuotaWithOptions(request, headers, runtime);
    }
    async managementBuyQuotaWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.order))) {
            body["order"] = request.order;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            body["token"] = request.token;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ManagementBuyQuota", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/managements/quotas/buy`, "none", req, runtime), new ManagementBuyQuotaResponse({}));
    }
    async managementListSpaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ManagementListSpacesHeaders({});
        return await this.managementListSpacesWithOptions(request, headers, runtime);
    }
    async managementListSpacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.spaceIds)) {
            body["spaceIds"] = request.spaceIds;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ManagementListSpaces", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/managements/spaces/query`, "json", req, runtime), new ManagementListSpacesResponse({}));
    }
    async managementModifySpace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ManagementModifySpaceHeaders({});
        return await this.managementModifySpaceWithOptions(request, headers, runtime);
    }
    async managementModifySpaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.quota)) {
            body["quota"] = request.quota;
        }
        if (!tea_util_1.default.isUnset(request.spaceIds)) {
            body["spaceIds"] = request.spaceIds;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ManagementModifySpace", "drive_1.0", "HTTP", "PUT", "AK", `/v1.0/drive/managements/spaces`, "json", req, runtime), new ManagementModifySpaceResponse({}));
    }
    async modifyPermission(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ModifyPermissionHeaders({});
        return await this.modifyPermissionWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async modifyPermissionWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ModifyPermission", "drive_1.0", "HTTP", "PUT", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/permissions`, "none", req, runtime), new ModifyPermissionResponse({}));
    }
    async moveFile(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MoveFileHeaders({});
        return await this.moveFileWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async moveFileWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.addConflictPolicy)) {
            body["addConflictPolicy"] = request.addConflictPolicy;
        }
        if (!tea_util_1.default.isUnset(request.targetParentId)) {
            body["targetParentId"] = request.targetParentId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("MoveFile", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/move`, "json", req, runtime), new MoveFileResponse({}));
    }
    async moveFiles(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MoveFilesHeaders({});
        return await this.moveFilesWithOptions(spaceId, request, headers, runtime);
    }
    async moveFilesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.addConflictPolicy)) {
            body["addConflictPolicy"] = request.addConflictPolicy;
        }
        if (!tea_util_1.default.isUnset(request.fileIds)) {
            body["fileIds"] = request.fileIds;
        }
        if (!tea_util_1.default.isUnset(request.targetParentId)) {
            body["targetParentId"] = request.targetParentId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("MoveFiles", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/batchMove`, "json", req, runtime), new MoveFilesResponse({}));
    }
    async recoverRecycleFiles(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RecoverRecycleFilesHeaders({});
        return await this.recoverRecycleFilesWithOptions(request, headers, runtime);
    }
    async recoverRecycleFilesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.recycleItemIdList)) {
            body["recycleItemIdList"] = request.recycleItemIdList;
        }
        if (!tea_util_1.default.isUnset(request.recycleType)) {
            body["recycleType"] = request.recycleType;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RecoverRecycleFiles", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/recycleItems/recover`, "none", req, runtime), new RecoverRecycleFilesResponse({}));
    }
    async renameFile(spaceId, fileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RenameFileHeaders({});
        return await this.renameFileWithOptions(spaceId, fileId, request, headers, runtime);
    }
    async renameFileWithOptions(spaceId, fileId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        fileId = openapi_util_1.default.getEncodeParam(fileId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.newFileName)) {
            body["newFileName"] = request.newFileName;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RenameFile", "drive_1.0", "HTTP", "POST", "AK", `/v1.0/drive/spaces/${spaceId}/files/${fileId}/rename`, "json", req, runtime), new RenameFileResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map