"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class DentryModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createdTime: 'createdTime',
            creator: 'creator',
            dentryId: 'dentryId',
            dentryType: 'dentryType',
            dentryUuid: 'dentryUuid',
            docKey: 'docKey',
            extension: 'extension',
            hasChildren: 'hasChildren',
            linkSourceInfo: 'linkSourceInfo',
            name: 'name',
            path: 'path',
            space: 'space',
            spaceId: 'spaceId',
            updatedTime: 'updatedTime',
            updater: 'updater',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createdTime: 'number',
            creator: DentryModelCreator,
            dentryId: 'string',
            dentryType: 'string',
            dentryUuid: 'string',
            docKey: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            linkSourceInfo: LinkSourceInfo,
            name: 'string',
            path: 'string',
            space: SpaceModel,
            spaceId: 'string',
            updatedTime: 'number',
            updater: DentryModelUpdater,
            url: 'string',
            visitorInfo: DentryModelVisitorInfo,
        };
    }
}
exports.DentryModel = DentryModel;
class DentryVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createdTime: 'createdTime',
            creator: 'creator',
            dentryId: 'dentryId',
            dentryType: 'dentryType',
            dentryUuid: 'dentryUuid',
            docKey: 'docKey',
            extension: 'extension',
            hasChildren: 'hasChildren',
            linkSourceInfo: 'linkSourceInfo',
            name: 'name',
            path: 'path',
            space: 'space',
            spaceId: 'spaceId',
            updatedTime: 'updatedTime',
            updater: 'updater',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createdTime: 'number',
            creator: DentryVOCreator,
            dentryId: 'string',
            dentryType: 'string',
            dentryUuid: 'string',
            docKey: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            linkSourceInfo: LinkSourceInfo,
            name: 'string',
            path: 'string',
            space: SpaceModel,
            spaceId: 'string',
            updatedTime: 'number',
            updater: DentryVOUpdater,
            url: 'string',
            visitorInfo: DentryVOVisitorInfo,
        };
    }
}
exports.DentryVO = DentryVO;
class LinkSourceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            iconUrl: 'iconUrl',
            id: 'id',
            linkType: 'linkType',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            extension: 'string',
            iconUrl: LinkSourceInfoIconUrl,
            id: 'string',
            linkType: 'number',
            spaceId: 'string',
        };
    }
}
exports.LinkSourceInfo = LinkSourceInfo;
class OpenActionModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            name: 'string',
            timestamp: 'number',
        };
    }
}
exports.OpenActionModel = OpenActionModel;
class SpaceModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            description: 'description',
            iconVO: 'iconVO',
            id: 'id',
            name: 'name',
            owner: 'owner',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            cover: 'string',
            description: 'string',
            iconVO: SpaceModelIconVO,
            id: 'string',
            name: 'string',
            owner: SpaceModelOwner,
            url: 'string',
            visitorInfo: SpaceModelVisitorInfo,
        };
    }
}
exports.SpaceModel = SpaceModel;
class SpaceVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            description: 'description',
            iconVO: 'iconVO',
            id: 'id',
            name: 'name',
            owner: 'owner',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            cover: 'string',
            description: 'string',
            iconVO: SpaceVOIconVO,
            id: 'string',
            name: 'string',
            owner: SpaceVOOwner,
            url: 'string',
            visitorInfo: SpaceVOVisitorInfo,
        };
    }
}
exports.SpaceVO = SpaceVO;
class CopyDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CopyDentryHeaders = CopyDentryHeaders;
class CopyDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            operatorId: 'operatorId',
            targetSpaceId: 'targetSpaceId',
            toNextDentryId: 'toNextDentryId',
            toParentDentryId: 'toParentDentryId',
            toPrevDentryId: 'toPrevDentryId',
        };
    }
    static types() {
        return {
            name: 'string',
            operatorId: 'string',
            targetSpaceId: 'string',
            toNextDentryId: 'string',
            toParentDentryId: 'string',
            toPrevDentryId: 'string',
        };
    }
}
exports.CopyDentryRequest = CopyDentryRequest;
class CopyDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DentryVO,
        };
    }
}
exports.CopyDentryResponse = CopyDentryResponse;
class CreateDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateDentryHeaders = CreateDentryHeaders;
class CreateDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryType: 'dentryType',
            documentType: 'documentType',
            name: 'name',
            operatorId: 'operatorId',
            parentDentryId: 'parentDentryId',
        };
    }
    static types() {
        return {
            dentryType: 'string',
            documentType: 'number',
            name: 'string',
            operatorId: 'string',
            parentDentryId: 'string',
        };
    }
}
exports.CreateDentryRequest = CreateDentryRequest;
class CreateDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DentryVO,
        };
    }
}
exports.CreateDentryResponse = CreateDentryResponse;
class GetSpaceDirectoriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSpaceDirectoriesHeaders = GetSpaceDirectoriesHeaders;
class GetSpaceDirectoriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryId: 'dentryId',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            dentryId: 'string',
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
        };
    }
}
exports.GetSpaceDirectoriesRequest = GetSpaceDirectoriesRequest;
class GetSpaceDirectoriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            children: 'children',
            hasMore: 'hasMore',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            children: { 'type': 'array', 'itemType': DentryModel },
            hasMore: 'boolean',
            nextToken: 'string',
        };
    }
}
exports.GetSpaceDirectoriesResponseBody = GetSpaceDirectoriesResponseBody;
class GetSpaceDirectoriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetSpaceDirectoriesResponseBody,
        };
    }
}
exports.GetSpaceDirectoriesResponse = GetSpaceDirectoriesResponse;
class GetUserInfoByOpenTokenHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetUserInfoByOpenTokenHeaders = GetUserInfoByOpenTokenHeaders;
class GetUserInfoByOpenTokenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            docKey: 'docKey',
            openToken: 'openToken',
        };
    }
    static types() {
        return {
            docKey: 'string',
            openToken: 'string',
        };
    }
}
exports.GetUserInfoByOpenTokenRequest = GetUserInfoByOpenTokenRequest;
class GetUserInfoByOpenTokenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            unionId: 'string',
            userId: 'string',
        };
    }
}
exports.GetUserInfoByOpenTokenResponseBody = GetUserInfoByOpenTokenResponseBody;
class GetUserInfoByOpenTokenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetUserInfoByOpenTokenResponseBody,
        };
    }
}
exports.GetUserInfoByOpenTokenResponse = GetUserInfoByOpenTokenResponse;
class MoveDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MoveDentryHeaders = MoveDentryHeaders;
class MoveDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
            targetSpaceId: 'targetSpaceId',
            toNextDentryId: 'toNextDentryId',
            toParentDentryId: 'toParentDentryId',
            toPrevDentryId: 'toPrevDentryId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            targetSpaceId: 'string',
            toNextDentryId: 'string',
            toParentDentryId: 'string',
            toPrevDentryId: 'string',
        };
    }
}
exports.MoveDentryRequest = MoveDentryRequest;
class MoveDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DentryVO,
        };
    }
}
exports.MoveDentryResponse = MoveDentryResponse;
class QueryDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryDentryHeaders = QueryDentryHeaders;
class QueryDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            includeSpace: 'includeSpace',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            includeSpace: 'boolean',
            operatorId: 'string',
        };
    }
}
exports.QueryDentryRequest = QueryDentryRequest;
class QueryDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DentryVO,
        };
    }
}
exports.QueryDentryResponse = QueryDentryResponse;
class QueryMineSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryMineSpaceHeaders = QueryMineSpaceHeaders;
class QueryMineSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SpaceVO,
        };
    }
}
exports.QueryMineSpaceResponse = QueryMineSpaceResponse;
class QueryRecentListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryRecentListHeaders = QueryRecentListHeaders;
class QueryRecentListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorType: 'creatorType',
            fileType: 'fileType',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            recentType: 'recentType',
        };
    }
    static types() {
        return {
            creatorType: 'number',
            fileType: 'number',
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            recentType: 'number',
        };
    }
}
exports.QueryRecentListRequest = QueryRecentListRequest;
class QueryRecentListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            recentList: 'recentList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            recentList: { 'type': 'array', 'itemType': QueryRecentListResponseBodyRecentList },
        };
    }
}
exports.QueryRecentListResponseBody = QueryRecentListResponseBody;
class QueryRecentListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryRecentListResponseBody,
        };
    }
}
exports.QueryRecentListResponse = QueryRecentListResponse;
class QuerySpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QuerySpaceHeaders = QuerySpaceHeaders;
class QuerySpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.QuerySpaceRequest = QuerySpaceRequest;
class QuerySpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SpaceVO,
        };
    }
}
exports.QuerySpaceResponse = QuerySpaceResponse;
class RelatedSpacesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RelatedSpacesHeaders = RelatedSpacesHeaders;
class RelatedSpacesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            teamId: 'teamId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            teamId: 'string',
        };
    }
}
exports.RelatedSpacesRequest = RelatedSpacesRequest;
class RelatedSpacesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': SpaceModel },
            nextToken: 'string',
        };
    }
}
exports.RelatedSpacesResponseBody = RelatedSpacesResponseBody;
class RelatedSpacesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: RelatedSpacesResponseBody,
        };
    }
}
exports.RelatedSpacesResponse = RelatedSpacesResponse;
class RenameDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RenameDentryHeaders = RenameDentryHeaders;
class RenameDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            name: 'string',
            operatorId: 'string',
        };
    }
}
exports.RenameDentryRequest = RenameDentryRequest;
class RenameDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DentryVO,
        };
    }
}
exports.RenameDentryResponse = RenameDentryResponse;
class SearchHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SearchHeaders = SearchHeaders;
class SearchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryRequest: 'dentryRequest',
            keyword: 'keyword',
            operatorId: 'operatorId',
            spaceRequest: 'spaceRequest',
        };
    }
    static types() {
        return {
            dentryRequest: SearchRequestDentryRequest,
            keyword: 'string',
            operatorId: 'string',
            spaceRequest: SearchRequestSpaceRequest,
        };
    }
}
exports.SearchRequest = SearchRequest;
class SearchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryResult: 'dentryResult',
            spaceResult: 'spaceResult',
        };
    }
    static types() {
        return {
            dentryResult: SearchResponseBodyDentryResult,
            spaceResult: SearchResponseBodySpaceResult,
        };
    }
}
exports.SearchResponseBody = SearchResponseBody;
class SearchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SearchResponseBody,
        };
    }
}
exports.SearchResponse = SearchResponse;
class DentryModelCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryModelCreator = DentryModelCreator;
class DentryModelUpdater extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryModelUpdater = DentryModelUpdater;
class DentryModelVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DentryModelVisitorInfo = DentryModelVisitorInfo;
class DentryVOCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryVOCreator = DentryVOCreator;
class DentryVOUpdater extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryVOUpdater = DentryVOUpdater;
class DentryVOVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DentryVOVisitorInfo = DentryVOVisitorInfo;
class LinkSourceInfoIconUrl extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            line: 'line',
            small: 'small',
        };
    }
    static types() {
        return {
            line: 'string',
            small: 'string',
        };
    }
}
exports.LinkSourceInfoIconUrl = LinkSourceInfoIconUrl;
class SpaceModelIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.SpaceModelIconVO = SpaceModelIconVO;
class SpaceModelOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.SpaceModelOwner = SpaceModelOwner;
class SpaceModelVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SpaceModelVisitorInfo = SpaceModelVisitorInfo;
class SpaceVOIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.SpaceVOIconVO = SpaceVOIconVO;
class SpaceVOOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.SpaceVOOwner = SpaceVOOwner;
class SpaceVOVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SpaceVOVisitorInfo = SpaceVOVisitorInfo;
class QueryRecentListResponseBodyRecentList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deleted: 'deleted',
            dentry: 'dentry',
            recentTime: 'recentTime',
        };
    }
    static types() {
        return {
            deleted: 'boolean',
            dentry: DentryModel,
            recentTime: 'number',
        };
    }
}
exports.QueryRecentListResponseBodyRecentList = QueryRecentListResponseBodyRecentList;
class SearchRequestDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            searchFileType: 'searchFileType',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            searchFileType: 'number',
            spaceId: 'string',
        };
    }
}
exports.SearchRequestDentryRequest = SearchRequestDentryRequest;
class SearchRequestSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.SearchRequestSpaceRequest = SearchRequestSpaceRequest;
class SearchResponseBodyDentryResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            creation: 'creation',
            dentryId: 'dentryId',
            dentryUuid: 'dentryUuid',
            extension: 'extension',
            iconUrl: 'iconUrl',
            lastEdition: 'lastEdition',
            name: 'name',
            originName: 'originName',
            path: 'path',
            searchFileType: 'searchFileType',
            spaceId: 'spaceId',
            url: 'url',
        };
    }
    static types() {
        return {
            content: 'string',
            creation: OpenActionModel,
            dentryId: 'string',
            dentryUuid: 'string',
            extension: 'string',
            iconUrl: 'string',
            lastEdition: OpenActionModel,
            name: 'string',
            originName: 'string',
            path: 'string',
            searchFileType: 'number',
            spaceId: 'string',
            url: 'string',
        };
    }
}
exports.SearchResponseBodyDentryResultItems = SearchResponseBodyDentryResultItems;
class SearchResponseBodyDentryResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': SearchResponseBodyDentryResultItems },
            nextToken: 'string',
        };
    }
}
exports.SearchResponseBodyDentryResult = SearchResponseBodyDentryResult;
class SearchResponseBodySpaceResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            originName: 'originName',
            spaceId: 'spaceId',
            url: 'url',
        };
    }
    static types() {
        return {
            name: 'string',
            originName: 'string',
            spaceId: 'string',
            url: 'string',
        };
    }
}
exports.SearchResponseBodySpaceResultItems = SearchResponseBodySpaceResultItems;
class SearchResponseBodySpaceResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': SearchResponseBodySpaceResultItems },
            nextToken: 'string',
        };
    }
}
exports.SearchResponseBodySpaceResult = SearchResponseBodySpaceResult;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async copyDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CopyDentryHeaders({});
        return await this.copyDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async copyDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        if (!tea_util_1.default.isUnset(request.toNextDentryId)) {
            body["toNextDentryId"] = request.toNextDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toParentDentryId)) {
            body["toParentDentryId"] = request.toParentDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toPrevDentryId)) {
            body["toPrevDentryId"] = request.toPrevDentryId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CopyDentry", "doc_2.0", "HTTP", "POST", "AK", `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}/copy`, "json", req, runtime), new CopyDentryResponse({}));
    }
    async createDentry(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateDentryHeaders({});
        return await this.createDentryWithOptions(spaceId, request, headers, runtime);
    }
    async createDentryWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryType)) {
            body["dentryType"] = request.dentryType;
        }
        if (!tea_util_1.default.isUnset(request.documentType)) {
            body["documentType"] = request.documentType;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.parentDentryId)) {
            body["parentDentryId"] = request.parentDentryId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateDentry", "doc_2.0", "HTTP", "POST", "AK", `/v2.0/doc/spaces/${spaceId}/dentries`, "json", req, runtime), new CreateDentryResponse({}));
    }
    async getSpaceDirectories(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSpaceDirectoriesHeaders({});
        return await this.getSpaceDirectoriesWithOptions(spaceId, request, headers, runtime);
    }
    async getSpaceDirectoriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dentryId)) {
            query["dentryId"] = request.dentryId;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetSpaceDirectories", "doc_2.0", "HTTP", "GET", "AK", `/v2.0/doc/spaces/${spaceId}/directories`, "json", req, runtime), new GetSpaceDirectoriesResponse({}));
    }
    async getUserInfoByOpenToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserInfoByOpenTokenHeaders({});
        return await this.getUserInfoByOpenTokenWithOptions(request, headers, runtime);
    }
    async getUserInfoByOpenTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.docKey)) {
            query["docKey"] = request.docKey;
        }
        if (!tea_util_1.default.isUnset(request.openToken)) {
            query["openToken"] = request.openToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetUserInfoByOpenToken", "doc_2.0", "HTTP", "GET", "AK", `/v2.0/doc/userInfos`, "json", req, runtime), new GetUserInfoByOpenTokenResponse({}));
    }
    async moveDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MoveDentryHeaders({});
        return await this.moveDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async moveDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        if (!tea_util_1.default.isUnset(request.toNextDentryId)) {
            body["toNextDentryId"] = request.toNextDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toParentDentryId)) {
            body["toParentDentryId"] = request.toParentDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toPrevDentryId)) {
            body["toPrevDentryId"] = request.toPrevDentryId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("MoveDentry", "doc_2.0", "HTTP", "POST", "AK", `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}/move`, "json", req, runtime), new MoveDentryResponse({}));
    }
    async queryDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryDentryHeaders({});
        return await this.queryDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async queryDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.includeSpace)) {
            query["includeSpace"] = request.includeSpace;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryDentry", "doc_2.0", "HTTP", "GET", "AK", `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}`, "json", req, runtime), new QueryDentryResponse({}));
    }
    async queryMineSpace(unionId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryMineSpaceHeaders({});
        return await this.queryMineSpaceWithOptions(unionId, headers, runtime);
    }
    async queryMineSpaceWithOptions(unionId, headers, runtime) {
        unionId = openapi_util_1.default.getEncodeParam(unionId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("QueryMineSpace", "doc_2.0", "HTTP", "GET", "AK", `/v2.0/doc/spaces/users/${unionId}/mine`, "json", req, runtime), new QueryMineSpaceResponse({}));
    }
    async queryRecentList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryRecentListHeaders({});
        return await this.queryRecentListWithOptions(request, headers, runtime);
    }
    async queryRecentListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.creatorType)) {
            query["creatorType"] = request.creatorType;
        }
        if (!tea_util_1.default.isUnset(request.fileType)) {
            query["fileType"] = request.fileType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.recentType)) {
            query["recentType"] = request.recentType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryRecentList", "doc_2.0", "HTTP", "GET", "AK", `/v2.0/doc/spaces/docs/recent`, "json", req, runtime), new QueryRecentListResponse({}));
    }
    async querySpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QuerySpaceHeaders({});
        return await this.querySpaceWithOptions(spaceId, request, headers, runtime);
    }
    async querySpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QuerySpace", "doc_2.0", "HTTP", "GET", "AK", `/v2.0/doc/spaces/${spaceId}`, "json", req, runtime), new QuerySpaceResponse({}));
    }
    async relatedSpaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RelatedSpacesHeaders({});
        return await this.relatedSpacesWithOptions(request, headers, runtime);
    }
    async relatedSpacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.teamId)) {
            query["teamId"] = request.teamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("RelatedSpaces", "doc_2.0", "HTTP", "GET", "AK", `/v2.0/doc/relations/spaces`, "json", req, runtime), new RelatedSpacesResponse({}));
    }
    async renameDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RenameDentryHeaders({});
        return await this.renameDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async renameDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        spaceId = openapi_util_1.default.getEncodeParam(spaceId);
        dentryId = openapi_util_1.default.getEncodeParam(dentryId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("RenameDentry", "doc_2.0", "HTTP", "POST", "AK", `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}/rename`, "json", req, runtime), new RenameDentryResponse({}));
    }
    async search(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchHeaders({});
        return await this.searchWithOptions(request, headers, runtime);
    }
    async searchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset($tea.toMap(request.dentryRequest))) {
            body["dentryRequest"] = request.dentryRequest;
        }
        if (!tea_util_1.default.isUnset(request.keyword)) {
            body["keyword"] = request.keyword;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.spaceRequest))) {
            body["spaceRequest"] = request.spaceRequest;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("Search", "doc_2.0", "HTTP", "POST", "AK", `/v2.0/doc/search`, "json", req, runtime), new SearchResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map