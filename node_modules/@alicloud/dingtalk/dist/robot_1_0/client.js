"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class BatchOTOQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchOTOQueryHeaders = BatchOTOQueryHeaders;
class BatchOTOQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            processQueryKey: 'processQueryKey',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
            robotCode: 'string',
        };
    }
}
exports.BatchOTOQueryRequest = BatchOTOQueryRequest;
class BatchOTOQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageReadInfoList: 'messageReadInfoList',
            sendStatus: 'sendStatus',
        };
    }
    static types() {
        return {
            messageReadInfoList: { 'type': 'array', 'itemType': BatchOTOQueryResponseBodyMessageReadInfoList },
            sendStatus: 'string',
        };
    }
}
exports.BatchOTOQueryResponseBody = BatchOTOQueryResponseBody;
class BatchOTOQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: BatchOTOQueryResponseBody,
        };
    }
}
exports.BatchOTOQueryResponse = BatchOTOQueryResponse;
class BatchRecallGroupHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchRecallGroupHeaders = BatchRecallGroupHeaders;
class BatchRecallGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatbotId: 'chatbotId',
            openConversationId: 'openConversationId',
            processQueryKeys: 'processQueryKeys',
        };
    }
    static types() {
        return {
            chatbotId: 'string',
            openConversationId: 'string',
            processQueryKeys: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchRecallGroupRequest = BatchRecallGroupRequest;
class BatchRecallGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedResult: 'failedResult',
            successResult: 'successResult',
        };
    }
    static types() {
        return {
            failedResult: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            successResult: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchRecallGroupResponseBody = BatchRecallGroupResponseBody;
class BatchRecallGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: BatchRecallGroupResponseBody,
        };
    }
}
exports.BatchRecallGroupResponse = BatchRecallGroupResponse;
class BatchRecallOTOHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchRecallOTOHeaders = BatchRecallOTOHeaders;
class BatchRecallOTORequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            processQueryKeys: 'processQueryKeys',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            processQueryKeys: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
}
exports.BatchRecallOTORequest = BatchRecallOTORequest;
class BatchRecallOTOResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedResult: 'failedResult',
            successResult: 'successResult',
        };
    }
    static types() {
        return {
            failedResult: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            successResult: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchRecallOTOResponseBody = BatchRecallOTOResponseBody;
class BatchRecallOTOResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: BatchRecallOTOResponseBody,
        };
    }
}
exports.BatchRecallOTOResponse = BatchRecallOTOResponse;
class BatchSendOTOHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchSendOTOHeaders = BatchSendOTOHeaders;
class BatchSendOTORequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            robotCode: 'robotCode',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            msgKey: 'string',
            msgParam: 'string',
            robotCode: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchSendOTORequest = BatchSendOTORequest;
class BatchSendOTOResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            flowControlledStaffIdList: 'flowControlledStaffIdList',
            invalidStaffIdList: 'invalidStaffIdList',
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            flowControlledStaffIdList: { 'type': 'array', 'itemType': 'string' },
            invalidStaffIdList: { 'type': 'array', 'itemType': 'string' },
            processQueryKey: 'string',
        };
    }
}
exports.BatchSendOTOResponseBody = BatchSendOTOResponseBody;
class BatchSendOTOResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: BatchSendOTOResponseBody,
        };
    }
}
exports.BatchSendOTOResponse = BatchSendOTOResponse;
class OrgGroupQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.OrgGroupQueryHeaders = OrgGroupQueryHeaders;
class OrgGroupQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            processQueryKey: 'processQueryKey',
            robotCode: 'robotCode',
            token: 'token',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            processQueryKey: 'string',
            robotCode: 'string',
            token: 'string',
        };
    }
}
exports.OrgGroupQueryRequest = OrgGroupQueryRequest;
class OrgGroupQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            readUserIds: 'readUserIds',
            sendStatus: 'sendStatus',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            readUserIds: { 'type': 'array', 'itemType': 'string' },
            sendStatus: 'string',
        };
    }
}
exports.OrgGroupQueryResponseBody = OrgGroupQueryResponseBody;
class OrgGroupQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: OrgGroupQueryResponseBody,
        };
    }
}
exports.OrgGroupQueryResponse = OrgGroupQueryResponse;
class OrgGroupRecallHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.OrgGroupRecallHeaders = OrgGroupRecallHeaders;
class OrgGroupRecallRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
            processQueryKeys: 'processQueryKeys',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            processQueryKeys: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
}
exports.OrgGroupRecallRequest = OrgGroupRecallRequest;
class OrgGroupRecallResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedResult: 'failedResult',
            successResult: 'successResult',
        };
    }
    static types() {
        return {
            failedResult: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            successResult: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.OrgGroupRecallResponseBody = OrgGroupRecallResponseBody;
class OrgGroupRecallResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: OrgGroupRecallResponseBody,
        };
    }
}
exports.OrgGroupRecallResponse = OrgGroupRecallResponse;
class OrgGroupSendHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.OrgGroupSendHeaders = OrgGroupSendHeaders;
class OrgGroupSendRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            openConversationId: 'openConversationId',
            robotCode: 'robotCode',
            token: 'token',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            msgKey: 'string',
            msgParam: 'string',
            openConversationId: 'string',
            robotCode: 'string',
            token: 'string',
        };
    }
}
exports.OrgGroupSendRequest = OrgGroupSendRequest;
class OrgGroupSendResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
}
exports.OrgGroupSendResponseBody = OrgGroupSendResponseBody;
class OrgGroupSendResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: OrgGroupSendResponseBody,
        };
    }
}
exports.OrgGroupSendResponse = OrgGroupSendResponse;
class SendRobotDingMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendRobotDingMessageHeaders = SendRobotDingMessageHeaders;
class SendRobotDingMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentParams: 'contentParams',
            dingTemplateId: 'dingTemplateId',
            openConversationId: 'openConversationId',
            receiverUserIdList: 'receiverUserIdList',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            contentParams: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            dingTemplateId: 'string',
            openConversationId: 'string',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
}
exports.SendRobotDingMessageRequest = SendRobotDingMessageRequest;
class SendRobotDingMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingSendResultId: 'dingSendResultId',
        };
    }
    static types() {
        return {
            dingSendResultId: 'string',
        };
    }
}
exports.SendRobotDingMessageResponseBody = SendRobotDingMessageResponseBody;
class SendRobotDingMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SendRobotDingMessageResponseBody,
        };
    }
}
exports.SendRobotDingMessageResponse = SendRobotDingMessageResponse;
class UpdateInstalledRobotHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateInstalledRobotHeaders = UpdateInstalledRobotHeaders;
class UpdateInstalledRobotRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            brief: 'brief',
            description: 'description',
            icon: 'icon',
            name: 'name',
            robotCode: 'robotCode',
            updateType: 'updateType',
        };
    }
    static types() {
        return {
            brief: 'string',
            description: 'string',
            icon: 'string',
            name: 'string',
            robotCode: 'string',
            updateType: 'number',
        };
    }
}
exports.UpdateInstalledRobotRequest = UpdateInstalledRobotRequest;
class UpdateInstalledRobotResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdateInstalledRobotResponseBody = UpdateInstalledRobotResponseBody;
class UpdateInstalledRobotResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateInstalledRobotResponseBody,
        };
    }
}
exports.UpdateInstalledRobotResponse = UpdateInstalledRobotResponse;
class BatchOTOQueryResponseBodyMessageReadInfoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            readStatus: 'readStatus',
            readTimestamp: 'readTimestamp',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            readStatus: 'string',
            readTimestamp: 'number',
            userId: 'string',
        };
    }
}
exports.BatchOTOQueryResponseBodyMessageReadInfoList = BatchOTOQueryResponseBodyMessageReadInfoList;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async batchOTOQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchOTOQueryHeaders({});
        return await this.batchOTOQueryWithOptions(request, headers, runtime);
    }
    async batchOTOQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.processQueryKey)) {
            query["processQueryKey"] = request.processQueryKey;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            query["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("BatchOTOQuery", "robot_1.0", "HTTP", "GET", "AK", `/v1.0/robot/oToMessages/readStatus`, "json", req, runtime), new BatchOTOQueryResponse({}));
    }
    async batchRecallGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchRecallGroupHeaders({});
        return await this.batchRecallGroupWithOptions(request, headers, runtime);
    }
    async batchRecallGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatbotId)) {
            body["chatbotId"] = request.chatbotId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKeys)) {
            body["processQueryKeys"] = request.processQueryKeys;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("BatchRecallGroup", "robot_1.0", "HTTP", "POST", "AK", `/v1.0/robot/groupMessages/batchRecall`, "json", req, runtime), new BatchRecallGroupResponse({}));
    }
    async batchRecallOTO(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchRecallOTOHeaders({});
        return await this.batchRecallOTOWithOptions(request, headers, runtime);
    }
    async batchRecallOTOWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.processQueryKeys)) {
            body["processQueryKeys"] = request.processQueryKeys;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("BatchRecallOTO", "robot_1.0", "HTTP", "POST", "AK", `/v1.0/robot/otoMessages/batchRecall`, "json", req, runtime), new BatchRecallOTOResponse({}));
    }
    async batchSendOTO(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchSendOTOHeaders({});
        return await this.batchSendOTOWithOptions(request, headers, runtime);
    }
    async batchSendOTOWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("BatchSendOTO", "robot_1.0", "HTTP", "POST", "AK", `/v1.0/robot/oToMessages/batchSend`, "json", req, runtime), new BatchSendOTOResponse({}));
    }
    async orgGroupQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OrgGroupQueryHeaders({});
        return await this.orgGroupQueryWithOptions(request, headers, runtime);
    }
    async orgGroupQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKey)) {
            body["processQueryKey"] = request.processQueryKey;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            body["token"] = request.token;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("OrgGroupQuery", "robot_1.0", "HTTP", "POST", "AK", `/v1.0/robot/groupMessages/query`, "json", req, runtime), new OrgGroupQueryResponse({}));
    }
    async orgGroupRecall(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OrgGroupRecallHeaders({});
        return await this.orgGroupRecallWithOptions(request, headers, runtime);
    }
    async orgGroupRecallWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKeys)) {
            body["processQueryKeys"] = request.processQueryKeys;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("OrgGroupRecall", "robot_1.0", "HTTP", "POST", "AK", `/v1.0/robot/groupMessages/recall`, "json", req, runtime), new OrgGroupRecallResponse({}));
    }
    async orgGroupSend(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OrgGroupSendHeaders({});
        return await this.orgGroupSendWithOptions(request, headers, runtime);
    }
    async orgGroupSendWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            body["token"] = request.token;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("OrgGroupSend", "robot_1.0", "HTTP", "POST", "AK", `/v1.0/robot/groupMessages/send`, "json", req, runtime), new OrgGroupSendResponse({}));
    }
    async sendRobotDingMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendRobotDingMessageHeaders({});
        return await this.sendRobotDingMessageWithOptions(request, headers, runtime);
    }
    async sendRobotDingMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.contentParams)) {
            body["contentParams"] = request.contentParams;
        }
        if (!tea_util_1.default.isUnset(request.dingTemplateId)) {
            body["dingTemplateId"] = request.dingTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("SendRobotDingMessage", "robot_1.0", "HTTP", "POST", "AK", `/v1.0/robot/dingMessages/send`, "json", req, runtime), new SendRobotDingMessageResponse({}));
    }
    async updateInstalledRobot(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateInstalledRobotHeaders({});
        return await this.updateInstalledRobotWithOptions(request, headers, runtime);
    }
    async updateInstalledRobotWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.brief)) {
            body["brief"] = request.brief;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.updateType)) {
            body["updateType"] = request.updateType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateInstalledRobot", "robot_1.0", "HTTP", "PUT", "AK", `/v1.0/robot/managements/infos`, "json", req, runtime), new UpdateInstalledRobotResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map