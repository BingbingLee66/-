"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddGroupMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddGroupMembersHeaders = AddGroupMembersHeaders;
class AddGroupMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conversationId: 'conversationId',
            members: 'members',
            operatorUid: 'operatorUid',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            members: { 'type': 'array', 'itemType': AddGroupMembersRequestMembers },
            operatorUid: 'string',
        };
    }
}
exports.AddGroupMembersRequest = AddGroupMembersRequest;
class AddGroupMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberUids: 'memberUids',
        };
    }
    static types() {
        return {
            memberUids: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.AddGroupMembersResponseBody = AddGroupMembersResponseBody;
class AddGroupMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddGroupMembersResponseBody,
        };
    }
}
exports.AddGroupMembersResponse = AddGroupMembersResponse;
class AddProfileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddProfileHeaders = AddProfileHeaders;
class AddProfileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appUid: 'appUid',
            avatarMediaId: 'avatarMediaId',
            mobileNumber: 'mobileNumber',
            nick: 'nick',
        };
    }
    static types() {
        return {
            appUid: 'string',
            avatarMediaId: 'string',
            mobileNumber: 'string',
            nick: 'string',
        };
    }
}
exports.AddProfileRequest = AddProfileRequest;
class AddProfileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.AddProfileResponse = AddProfileResponse;
class BatchSendHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchSendHeaders = BatchSendHeaders;
class BatchSendRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appUids: 'appUids',
            content: 'content',
            conversationIds: 'conversationIds',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUids: { 'type': 'array', 'itemType': 'string' },
            content: 'string',
            conversationIds: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
}
exports.BatchSendRequest = BatchSendRequest;
class BatchSendResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            taskId: 'string',
        };
    }
}
exports.BatchSendResponseBody = BatchSendResponseBody;
class BatchSendResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: BatchSendResponseBody,
        };
    }
}
exports.BatchSendResponse = BatchSendResponse;
class CreateGroupHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateGroupHeaders = CreateGroupHeaders;
class CreateGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channel: 'channel',
            creatorUid: 'creatorUid',
            iconMediaId: 'iconMediaId',
            name: 'name',
            properties: 'properties',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            channel: 'string',
            creatorUid: 'string',
            iconMediaId: 'string',
            name: 'string',
            properties: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            uuid: 'string',
        };
    }
}
exports.CreateGroupRequest = CreateGroupRequest;
class CreateGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatId: 'chatId',
            conversationId: 'conversationId',
            createTime: 'createTime',
        };
    }
    static types() {
        return {
            chatId: 'string',
            conversationId: 'string',
            createTime: 'number',
        };
    }
}
exports.CreateGroupResponseBody = CreateGroupResponseBody;
class CreateGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateGroupResponseBody,
        };
    }
}
exports.CreateGroupResponse = CreateGroupResponse;
class CreateTrustGroupHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateTrustGroupHeaders = CreateTrustGroupHeaders;
class CreateTrustGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            channel: 'channel',
            iconMediaId: 'iconMediaId',
            name: 'name',
            properties: 'properties',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            channel: 'string',
            iconMediaId: 'string',
            name: 'string',
            properties: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            uuid: 'string',
        };
    }
}
exports.CreateTrustGroupRequest = CreateTrustGroupRequest;
class CreateTrustGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatId: 'chatId',
            createTime: 'createTime',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            chatId: 'string',
            createTime: 'number',
            openConversationId: 'string',
        };
    }
}
exports.CreateTrustGroupResponseBody = CreateTrustGroupResponseBody;
class CreateTrustGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateTrustGroupResponseBody,
        };
    }
}
exports.CreateTrustGroupResponse = CreateTrustGroupResponse;
class DismissGroupHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DismissGroupHeaders = DismissGroupHeaders;
class DismissGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conversationId: 'conversationId',
            operatorUid: 'operatorUid',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            operatorUid: 'string',
        };
    }
}
exports.DismissGroupRequest = DismissGroupRequest;
class DismissGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.DismissGroupResponse = DismissGroupResponse;
class GetConversationIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetConversationIdHeaders = GetConversationIdHeaders;
class GetConversationIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appUid: 'appUid',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUid: 'string',
            userId: 'string',
        };
    }
}
exports.GetConversationIdRequest = GetConversationIdRequest;
class GetConversationIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conversationId: 'conversationId',
        };
    }
    static types() {
        return {
            conversationId: 'string',
        };
    }
}
exports.GetConversationIdResponseBody = GetConversationIdResponseBody;
class GetConversationIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetConversationIdResponseBody,
        };
    }
}
exports.GetConversationIdResponse = GetConversationIdResponse;
class GetMediaUrlHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetMediaUrlHeaders = GetMediaUrlHeaders;
class GetMediaUrlRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mediaId: 'mediaId',
            urlExpireTime: 'urlExpireTime',
        };
    }
    static types() {
        return {
            mediaId: 'string',
            urlExpireTime: 'number',
        };
    }
}
exports.GetMediaUrlRequest = GetMediaUrlRequest;
class GetMediaUrlResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.GetMediaUrlResponseBody = GetMediaUrlResponseBody;
class GetMediaUrlResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetMediaUrlResponseBody,
        };
    }
}
exports.GetMediaUrlResponse = GetMediaUrlResponse;
class ListGroupStaffMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListGroupStaffMembersHeaders = ListGroupStaffMembersHeaders;
class ListGroupStaffMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conversationId: 'conversationId',
        };
    }
    static types() {
        return {
            conversationId: 'string',
        };
    }
}
exports.ListGroupStaffMembersRequest = ListGroupStaffMembersRequest;
class ListGroupStaffMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': ListGroupStaffMembersResponseBodyMembers },
        };
    }
}
exports.ListGroupStaffMembersResponseBody = ListGroupStaffMembersResponseBody;
class ListGroupStaffMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListGroupStaffMembersResponseBody,
        };
    }
}
exports.ListGroupStaffMembersResponse = ListGroupStaffMembersResponse;
class QueryBatchSendResultHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryBatchSendResultHeaders = QueryBatchSendResultHeaders;
class QueryBatchSendResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            senderUserId: 'senderUserId',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            senderUserId: 'string',
            taskId: 'string',
        };
    }
}
exports.QueryBatchSendResultRequest = QueryBatchSendResultRequest;
class QueryBatchSendResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
            status: 'status',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': QueryBatchSendResultResponseBodyResults },
            status: 'number',
        };
    }
}
exports.QueryBatchSendResultResponseBody = QueryBatchSendResultResponseBody;
class QueryBatchSendResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryBatchSendResultResponseBody,
        };
    }
}
exports.QueryBatchSendResultResponse = QueryBatchSendResultResponse;
class ReadMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ReadMessageHeaders = ReadMessageHeaders;
class ReadMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageId: 'messageId',
            operatorUid: 'operatorUid',
        };
    }
    static types() {
        return {
            messageId: 'string',
            operatorUid: 'string',
        };
    }
}
exports.ReadMessageRequest = ReadMessageRequest;
class ReadMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.ReadMessageResponse = ReadMessageResponse;
class RecallMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RecallMessageHeaders = RecallMessageHeaders;
class RecallMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageId: 'messageId',
            operatorUid: 'operatorUid',
            type: 'type',
        };
    }
    static types() {
        return {
            messageId: 'string',
            operatorUid: 'string',
            type: 'number',
        };
    }
}
exports.RecallMessageRequest = RecallMessageRequest;
class RecallMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.RecallMessageResponse = RecallMessageResponse;
class RemoveGroupMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RemoveGroupMembersHeaders = RemoveGroupMembersHeaders;
class RemoveGroupMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conversationId: 'conversationId',
            memberUids: 'memberUids',
            operatorUid: 'operatorUid',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            memberUids: { 'type': 'array', 'itemType': 'string' },
            operatorUid: 'string',
        };
    }
}
exports.RemoveGroupMembersRequest = RemoveGroupMembersRequest;
class RemoveGroupMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.RemoveGroupMembersResponse = RemoveGroupMembersResponse;
class SendMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendMessageHeaders = SendMessageHeaders;
class SendMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            conversationId: 'conversationId',
            createTime: 'createTime',
            receiverUid: 'receiverUid',
            senderUid: 'senderUid',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            content: 'string',
            conversationId: 'string',
            createTime: 'number',
            receiverUid: 'string',
            senderUid: 'string',
            uuid: 'string',
        };
    }
}
exports.SendMessageRequest = SendMessageRequest;
class SendMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            messageId: 'messageId',
            msgId: 'msgId',
        };
    }
    static types() {
        return {
            createTime: 'number',
            messageId: 'string',
            msgId: 'string',
        };
    }
}
exports.SendMessageResponseBody = SendMessageResponseBody;
class SendMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SendMessageResponseBody,
        };
    }
}
exports.SendMessageResponse = SendMessageResponse;
class UpdateGroupNameHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateGroupNameHeaders = UpdateGroupNameHeaders;
class UpdateGroupNameRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conversationId: 'conversationId',
            name: 'name',
            operatorUid: 'operatorUid',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            name: 'string',
            operatorUid: 'string',
        };
    }
}
exports.UpdateGroupNameRequest = UpdateGroupNameRequest;
class UpdateGroupNameResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.UpdateGroupNameResponse = UpdateGroupNameResponse;
class UpdateGroupOwnerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            operationSource: 'operationSource',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            operationSource: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateGroupOwnerHeaders = UpdateGroupOwnerHeaders;
class UpdateGroupOwnerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conversationId: 'conversationId',
            operatorUid: 'operatorUid',
            ownerUid: 'ownerUid',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            operatorUid: 'string',
            ownerUid: 'string',
        };
    }
}
exports.UpdateGroupOwnerRequest = UpdateGroupOwnerRequest;
class UpdateGroupOwnerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.UpdateGroupOwnerResponse = UpdateGroupOwnerResponse;
class AddGroupMembersRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nick: 'nick',
            uid: 'uid',
        };
    }
    static types() {
        return {
            nick: 'string',
            uid: 'string',
        };
    }
}
exports.AddGroupMembersRequestMembers = AddGroupMembersRequestMembers;
class ListGroupStaffMembersResponseBodyMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nick: 'nick',
            uid: 'uid',
        };
    }
    static types() {
        return {
            nick: 'string',
            uid: 'string',
        };
    }
}
exports.ListGroupStaffMembersResponseBodyMembers = ListGroupStaffMembersResponseBodyMembers;
class QueryBatchSendResultResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appUid: 'appUid',
            conversationId: 'conversationId',
            errorCode: 'errorCode',
            errorMessage: 'errorMessage',
            msgId: 'msgId',
        };
    }
    static types() {
        return {
            appUid: 'string',
            conversationId: 'string',
            errorCode: 'string',
            errorMessage: 'string',
            msgId: 'string',
        };
    }
}
exports.QueryBatchSendResultResponseBodyResults = QueryBatchSendResultResponseBodyResults;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addGroupMembers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddGroupMembersHeaders({});
        return await this.addGroupMembersWithOptions(request, headers, runtime);
    }
    async addGroupMembersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.operatorUid)) {
            body["operatorUid"] = request.operatorUid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddGroupMembers", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/groups/members/batchAdd`, "json", req, runtime), new AddGroupMembersResponse({}));
    }
    async addProfile(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddProfileHeaders({});
        return await this.addProfileWithOptions(request, headers, runtime);
    }
    async addProfileWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUid)) {
            body["appUid"] = request.appUid;
        }
        if (!tea_util_1.default.isUnset(request.avatarMediaId)) {
            body["avatarMediaId"] = request.avatarMediaId;
        }
        if (!tea_util_1.default.isUnset(request.mobileNumber)) {
            body["mobileNumber"] = request.mobileNumber;
        }
        if (!tea_util_1.default.isUnset(request.nick)) {
            body["nick"] = request.nick;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddProfile", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/users/profiles`, "none", req, runtime), new AddProfileResponse({}));
    }
    async batchSend(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchSendHeaders({});
        return await this.batchSendWithOptions(request, headers, runtime);
    }
    async batchSendWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUids)) {
            body["appUids"] = request.appUids;
        }
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.conversationIds)) {
            body["conversationIds"] = request.conversationIds;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("BatchSend", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/messages/batchSend`, "json", req, runtime), new BatchSendResponse({}));
    }
    async createGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateGroupHeaders({});
        return await this.createGroupWithOptions(request, headers, runtime);
    }
    async createGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.channel)) {
            body["channel"] = request.channel;
        }
        if (!tea_util_1.default.isUnset(request.creatorUid)) {
            body["creatorUid"] = request.creatorUid;
        }
        if (!tea_util_1.default.isUnset(request.iconMediaId)) {
            body["iconMediaId"] = request.iconMediaId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.properties)) {
            body["properties"] = request.properties;
        }
        if (!tea_util_1.default.isUnset(request.uuid)) {
            body["uuid"] = request.uuid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateGroup", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/groups`, "json", req, runtime), new CreateGroupResponse({}));
    }
    async createTrustGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateTrustGroupHeaders({});
        return await this.createTrustGroupWithOptions(request, headers, runtime);
    }
    async createTrustGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.channel)) {
            body["channel"] = request.channel;
        }
        if (!tea_util_1.default.isUnset(request.iconMediaId)) {
            body["iconMediaId"] = request.iconMediaId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.properties)) {
            body["properties"] = request.properties;
        }
        if (!tea_util_1.default.isUnset(request.uuid)) {
            body["uuid"] = request.uuid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateTrustGroup", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/groups/trusts`, "json", req, runtime), new CreateTrustGroupResponse({}));
    }
    async dismissGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DismissGroupHeaders({});
        return await this.dismissGroupWithOptions(request, headers, runtime);
    }
    async dismissGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUid)) {
            body["operatorUid"] = request.operatorUid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("DismissGroup", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/groups/dismiss`, "none", req, runtime), new DismissGroupResponse({}));
    }
    async getConversationId(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConversationIdHeaders({});
        return await this.getConversationIdWithOptions(request, headers, runtime);
    }
    async getConversationIdWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUid)) {
            body["appUid"] = request.appUid;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GetConversationId", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/conversations`, "json", req, runtime), new GetConversationIdResponse({}));
    }
    async getMediaUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetMediaUrlHeaders({});
        return await this.getMediaUrlWithOptions(request, headers, runtime);
    }
    async getMediaUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            body["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.urlExpireTime)) {
            body["urlExpireTime"] = request.urlExpireTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GetMediaUrl", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/medium/urls`, "json", req, runtime), new GetMediaUrlResponse({}));
    }
    async listGroupStaffMembers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListGroupStaffMembersHeaders({});
        return await this.listGroupStaffMembersWithOptions(request, headers, runtime);
    }
    async listGroupStaffMembersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ListGroupStaffMembers", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/groups/staffMemers/query`, "json", req, runtime), new ListGroupStaffMembersResponse({}));
    }
    async queryBatchSendResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryBatchSendResultHeaders({});
        return await this.queryBatchSendResultWithOptions(request, headers, runtime);
    }
    async queryBatchSendResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            query["senderUserId"] = request.senderUserId;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            query["taskId"] = request.taskId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryBatchSendResult", "impaas_1.0", "HTTP", "GET", "AK", `/v1.0/impaas/interconnections/messages/batchSendResults`, "json", req, runtime), new QueryBatchSendResultResponse({}));
    }
    async readMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReadMessageHeaders({});
        return await this.readMessageWithOptions(request, headers, runtime);
    }
    async readMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.messageId)) {
            body["messageId"] = request.messageId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUid)) {
            body["operatorUid"] = request.operatorUid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ReadMessage", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/messages/read`, "none", req, runtime), new ReadMessageResponse({}));
    }
    async recallMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RecallMessageHeaders({});
        return await this.recallMessageWithOptions(request, headers, runtime);
    }
    async recallMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.messageId)) {
            body["messageId"] = request.messageId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUid)) {
            body["operatorUid"] = request.operatorUid;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RecallMessage", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/messages/recall`, "none", req, runtime), new RecallMessageResponse({}));
    }
    async removeGroupMembers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RemoveGroupMembersHeaders({});
        return await this.removeGroupMembersWithOptions(request, headers, runtime);
    }
    async removeGroupMembersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.memberUids)) {
            body["memberUids"] = request.memberUids;
        }
        if (!tea_util_1.default.isUnset(request.operatorUid)) {
            body["operatorUid"] = request.operatorUid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RemoveGroupMembers", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/groups/members/batchRemove`, "none", req, runtime), new RemoveGroupMembersResponse({}));
    }
    async sendMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendMessageHeaders({});
        return await this.sendMessageWithOptions(request, headers, runtime);
    }
    async sendMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.createTime)) {
            body["createTime"] = request.createTime;
        }
        if (!tea_util_1.default.isUnset(request.receiverUid)) {
            body["receiverUid"] = request.receiverUid;
        }
        if (!tea_util_1.default.isUnset(request.senderUid)) {
            body["senderUid"] = request.senderUid;
        }
        if (!tea_util_1.default.isUnset(request.uuid)) {
            body["uuid"] = request.uuid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("SendMessage", "impaas_1.0", "HTTP", "POST", "AK", `/v1.0/impaas/interconnections/messages/send`, "json", req, runtime), new SendMessageResponse({}));
    }
    async updateGroupName(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupNameHeaders({});
        return await this.updateGroupNameWithOptions(request, headers, runtime);
    }
    async updateGroupNameWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorUid)) {
            body["operatorUid"] = request.operatorUid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateGroupName", "impaas_1.0", "HTTP", "PUT", "AK", `/v1.0/impaas/interconnections/groups/names`, "none", req, runtime), new UpdateGroupNameResponse({}));
    }
    async updateGroupOwner(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupOwnerHeaders({});
        return await this.updateGroupOwnerWithOptions(request, headers, runtime);
    }
    async updateGroupOwnerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationId)) {
            body["conversationId"] = request.conversationId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUid)) {
            body["operatorUid"] = request.operatorUid;
        }
        if (!tea_util_1.default.isUnset(request.ownerUid)) {
            body["ownerUid"] = request.ownerUid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.operationSource)) {
            realHeaders["operationSource"] = tea_util_1.default.toJSONString(headers.operationSource);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateGroupOwner", "impaas_1.0", "HTTP", "PUT", "AK", `/v1.0/impaas/interconnections/groups/owners`, "none", req, runtime), new UpdateGroupOwnerResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map