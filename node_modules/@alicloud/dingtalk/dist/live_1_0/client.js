"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddShareCidListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddShareCidListHeaders = AddShareCidListHeaders;
class AddShareCidListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupIdType: 'groupIdType',
            groupIds: 'groupIds',
            userId: 'userId',
        };
    }
    static types() {
        return {
            groupIdType: 'number',
            groupIds: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
}
exports.AddShareCidListRequest = AddShareCidListRequest;
class AddShareCidListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasShareSuccess: 'hasShareSuccess',
            shareSuccessGroupList: 'shareSuccessGroupList',
        };
    }
    static types() {
        return {
            hasShareSuccess: 'boolean',
            shareSuccessGroupList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.AddShareCidListResponseBody = AddShareCidListResponseBody;
class AddShareCidListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddShareCidListResponseBody,
        };
    }
}
exports.AddShareCidListResponse = AddShareCidListResponse;
class CreateCloudFeedHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateCloudFeedHeaders = CreateCloudFeedHeaders;
class CreateCloudFeedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coverUrl: 'coverUrl',
            intro: 'intro',
            startTime: 'startTime',
            title: 'title',
            userId: 'userId',
            videoUrl: 'videoUrl',
        };
    }
    static types() {
        return {
            coverUrl: 'string',
            intro: 'string',
            startTime: 'number',
            title: 'string',
            userId: 'string',
            videoUrl: 'string',
        };
    }
}
exports.CreateCloudFeedRequest = CreateCloudFeedRequest;
class CreateCloudFeedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.CreateCloudFeedResponseBody = CreateCloudFeedResponseBody;
class CreateCloudFeedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateCloudFeedResponseBody,
        };
    }
}
exports.CreateCloudFeedResponse = CreateCloudFeedResponse;
class DeleteLiveFeedHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteLiveFeedHeaders = DeleteLiveFeedHeaders;
class DeleteLiveFeedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.DeleteLiveFeedRequest = DeleteLiveFeedRequest;
class DeleteLiveFeedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasDelete: 'hasDelete',
        };
    }
    static types() {
        return {
            hasDelete: 'boolean',
        };
    }
}
exports.DeleteLiveFeedResponseBody = DeleteLiveFeedResponseBody;
class DeleteLiveFeedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteLiveFeedResponseBody,
        };
    }
}
exports.DeleteLiveFeedResponse = DeleteLiveFeedResponse;
class EditFeedReplayHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.EditFeedReplayHeaders = EditFeedReplayHeaders;
class EditFeedReplayRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            editEndTime: 'editEndTime',
            editStartTime: 'editStartTime',
            userId: 'userId',
        };
    }
    static types() {
        return {
            editEndTime: 'number',
            editStartTime: 'number',
            userId: 'string',
        };
    }
}
exports.EditFeedReplayRequest = EditFeedReplayRequest;
class EditFeedReplayResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.EditFeedReplayResponseBody = EditFeedReplayResponseBody;
class EditFeedReplayResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: EditFeedReplayResponseBody,
        };
    }
}
exports.EditFeedReplayResponse = EditFeedReplayResponse;
class ModifyFeedWhiteListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ModifyFeedWhiteListHeaders = ModifyFeedWhiteListHeaders;
class ModifyFeedWhiteListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            modifyUserList: 'modifyUserList',
            userId: 'userId',
        };
    }
    static types() {
        return {
            action: 'number',
            modifyUserList: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
}
exports.ModifyFeedWhiteListRequest = ModifyFeedWhiteListRequest;
class ModifyFeedWhiteListShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            modifyUserListShrink: 'modifyUserList',
            userId: 'userId',
        };
    }
    static types() {
        return {
            action: 'number',
            modifyUserListShrink: 'string',
            userId: 'string',
        };
    }
}
exports.ModifyFeedWhiteListShrinkRequest = ModifyFeedWhiteListShrinkRequest;
class ModifyFeedWhiteListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.ModifyFeedWhiteListResponseBody = ModifyFeedWhiteListResponseBody;
class ModifyFeedWhiteListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ModifyFeedWhiteListResponseBody,
        };
    }
}
exports.ModifyFeedWhiteListResponse = ModifyFeedWhiteListResponse;
class QueryFeedWhiteListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryFeedWhiteListHeaders = QueryFeedWhiteListHeaders;
class QueryFeedWhiteListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.QueryFeedWhiteListRequest = QueryFeedWhiteListRequest;
class QueryFeedWhiteListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.QueryFeedWhiteListResponseBody = QueryFeedWhiteListResponseBody;
class QueryFeedWhiteListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryFeedWhiteListResponseBody,
        };
    }
}
exports.QueryFeedWhiteListResponse = QueryFeedWhiteListResponse;
class StartCloudFeedHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StartCloudFeedHeaders = StartCloudFeedHeaders;
class StartCloudFeedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.StartCloudFeedRequest = StartCloudFeedRequest;
class StartCloudFeedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.StartCloudFeedResponseBody = StartCloudFeedResponseBody;
class StartCloudFeedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: StartCloudFeedResponseBody,
        };
    }
}
exports.StartCloudFeedResponse = StartCloudFeedResponse;
class StopCloudFeedHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StopCloudFeedHeaders = StopCloudFeedHeaders;
class StopCloudFeedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.StopCloudFeedRequest = StopCloudFeedRequest;
class StopCloudFeedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.StopCloudFeedResponseBody = StopCloudFeedResponseBody;
class StopCloudFeedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: StopCloudFeedResponseBody,
        };
    }
}
exports.StopCloudFeedResponse = StopCloudFeedResponse;
class UpdateLiveFeedHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateLiveFeedHeaders = UpdateLiveFeedHeaders;
class UpdateLiveFeedRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coverUrl: 'coverUrl',
            introduction: 'introduction',
            startTime: 'startTime',
            title: 'title',
            userId: 'userId',
        };
    }
    static types() {
        return {
            coverUrl: 'string',
            introduction: 'string',
            startTime: 'number',
            title: 'string',
            userId: 'string',
        };
    }
}
exports.UpdateLiveFeedRequest = UpdateLiveFeedRequest;
class UpdateLiveFeedResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasUpdate: 'hasUpdate',
        };
    }
    static types() {
        return {
            hasUpdate: 'boolean',
        };
    }
}
exports.UpdateLiveFeedResponseBody = UpdateLiveFeedResponseBody;
class UpdateLiveFeedResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateLiveFeedResponseBody,
        };
    }
}
exports.UpdateLiveFeedResponse = UpdateLiveFeedResponse;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addShareCidList(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddShareCidListHeaders({});
        return await this.addShareCidListWithOptions(feedId, request, headers, runtime);
    }
    async addShareCidListWithOptions(feedId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupIdType)) {
            body["groupIdType"] = request.groupIdType;
        }
        if (!tea_util_1.default.isUnset(request.groupIds)) {
            body["groupIds"] = request.groupIds;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddShareCidList", "live_1.0", "HTTP", "POST", "AK", `/v1.0/live/cloudFeeds/${feedId}/share`, "json", req, runtime), new AddShareCidListResponse({}));
    }
    async createCloudFeed(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateCloudFeedHeaders({});
        return await this.createCloudFeedWithOptions(request, headers, runtime);
    }
    async createCloudFeedWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coverUrl)) {
            body["coverUrl"] = request.coverUrl;
        }
        if (!tea_util_1.default.isUnset(request.intro)) {
            body["intro"] = request.intro;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.videoUrl)) {
            body["videoUrl"] = request.videoUrl;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateCloudFeed", "live_1.0", "HTTP", "POST", "AK", `/v1.0/live/cloudFeeds`, "json", req, runtime), new CreateCloudFeedResponse({}));
    }
    async deleteLiveFeed(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteLiveFeedHeaders({});
        return await this.deleteLiveFeedWithOptions(feedId, request, headers, runtime);
    }
    async deleteLiveFeedWithOptions(feedId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("DeleteLiveFeed", "live_1.0", "HTTP", "DELETE", "AK", `/v1.0/live/openFeeds/${feedId}`, "json", req, runtime), new DeleteLiveFeedResponse({}));
    }
    async editFeedReplay(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new EditFeedReplayHeaders({});
        return await this.editFeedReplayWithOptions(feedId, request, headers, runtime);
    }
    async editFeedReplayWithOptions(feedId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.editEndTime)) {
            body["editEndTime"] = request.editEndTime;
        }
        if (!tea_util_1.default.isUnset(request.editStartTime)) {
            body["editStartTime"] = request.editStartTime;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("EditFeedReplay", "live_1.0", "HTTP", "POST", "AK", `/v1.0/live/openFeeds/${feedId}/cutReplay`, "json", req, runtime), new EditFeedReplayResponse({}));
    }
    async modifyFeedWhiteList(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ModifyFeedWhiteListHeaders({});
        return await this.modifyFeedWhiteListWithOptions(feedId, request, headers, runtime);
    }
    async modifyFeedWhiteListWithOptions(feedId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let request = new ModifyFeedWhiteListShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.modifyUserList)) {
            request.modifyUserListShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.modifyUserList, "modifyUserList", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            query["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.modifyUserListShrink)) {
            query["modifyUserList"] = request.modifyUserListShrink;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ModifyFeedWhiteList", "live_1.0", "HTTP", "POST", "AK", `/v1.0/live/openFeeds/${feedId}/whiteList`, "json", req, runtime), new ModifyFeedWhiteListResponse({}));
    }
    async queryFeedWhiteList(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryFeedWhiteListHeaders({});
        return await this.queryFeedWhiteListWithOptions(feedId, request, headers, runtime);
    }
    async queryFeedWhiteListWithOptions(feedId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryFeedWhiteList", "live_1.0", "HTTP", "GET", "AK", `/v1.0/live/openFeeds/${feedId}/whiteList`, "json", req, runtime), new QueryFeedWhiteListResponse({}));
    }
    async startCloudFeed(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartCloudFeedHeaders({});
        return await this.startCloudFeedWithOptions(feedId, request, headers, runtime);
    }
    async startCloudFeedWithOptions(feedId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("StartCloudFeed", "live_1.0", "HTTP", "POST", "AK", `/v1.0/live/cloudFeeds/${feedId}/start`, "json", req, runtime), new StartCloudFeedResponse({}));
    }
    async stopCloudFeed(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopCloudFeedHeaders({});
        return await this.stopCloudFeedWithOptions(feedId, request, headers, runtime);
    }
    async stopCloudFeedWithOptions(feedId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("StopCloudFeed", "live_1.0", "HTTP", "POST", "AK", `/v1.0/live/cloudFeeds/${feedId}/stop`, "json", req, runtime), new StopCloudFeedResponse({}));
    }
    async updateLiveFeed(feedId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateLiveFeedHeaders({});
        return await this.updateLiveFeedWithOptions(feedId, request, headers, runtime);
    }
    async updateLiveFeedWithOptions(feedId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        feedId = openapi_util_1.default.getEncodeParam(feedId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.coverUrl)) {
            query["coverUrl"] = request.coverUrl;
        }
        if (!tea_util_1.default.isUnset(request.introduction)) {
            query["introduction"] = request.introduction;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            query["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("UpdateLiveFeed", "live_1.0", "HTTP", "POST", "AK", `/v1.0/live/openFeeds/${feedId}`, "json", req, runtime), new UpdateLiveFeedResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map