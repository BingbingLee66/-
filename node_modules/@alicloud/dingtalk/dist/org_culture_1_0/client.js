"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AssignOrgHoldingToEmpHoldingBatchHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AssignOrgHoldingToEmpHoldingBatchHeaders = AssignOrgHoldingToEmpHoldingBatchHeaders;
class AssignOrgHoldingToEmpHoldingBatchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            remark: 'remark',
            sendOrgCultureInform: 'sendOrgCultureInform',
            singleAmount: 'singleAmount',
            sourceUsage: 'sourceUsage',
            targetUsage: 'targetUsage',
            targetUserList: 'targetUserList',
        };
    }
    static types() {
        return {
            remark: 'string',
            sendOrgCultureInform: 'boolean',
            singleAmount: 'number',
            sourceUsage: 'string',
            targetUsage: 'string',
            targetUserList: { 'type': 'array', 'itemType': AssignOrgHoldingToEmpHoldingBatchRequestTargetUserList },
        };
    }
}
exports.AssignOrgHoldingToEmpHoldingBatchRequest = AssignOrgHoldingToEmpHoldingBatchRequest;
class AssignOrgHoldingToEmpHoldingBatchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: AssignOrgHoldingToEmpHoldingBatchResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.AssignOrgHoldingToEmpHoldingBatchResponseBody = AssignOrgHoldingToEmpHoldingBatchResponseBody;
class AssignOrgHoldingToEmpHoldingBatchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AssignOrgHoldingToEmpHoldingBatchResponseBody,
        };
    }
}
exports.AssignOrgHoldingToEmpHoldingBatchResponse = AssignOrgHoldingToEmpHoldingBatchResponse;
class ConsumeUserPointsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ConsumeUserPointsHeaders = ConsumeUserPointsHeaders;
class ConsumeUserPointsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            outId: 'outId',
            remark: 'remark',
            usage: 'usage',
        };
    }
    static types() {
        return {
            amount: 'number',
            outId: 'string',
            remark: 'string',
            usage: 'string',
        };
    }
}
exports.ConsumeUserPointsRequest = ConsumeUserPointsRequest;
class ConsumeUserPointsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: ConsumeUserPointsResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.ConsumeUserPointsResponseBody = ConsumeUserPointsResponseBody;
class ConsumeUserPointsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ConsumeUserPointsResponseBody,
        };
    }
}
exports.ConsumeUserPointsResponse = ConsumeUserPointsResponse;
class DeductionPointBatchHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeductionPointBatchHeaders = DeductionPointBatchHeaders;
class DeductionPointBatchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deductionAmount: 'deductionAmount',
            remark: 'remark',
            sendOrgCultureInform: 'sendOrgCultureInform',
            targetUserList: 'targetUserList',
            userId: 'userId',
        };
    }
    static types() {
        return {
            deductionAmount: 'number',
            remark: 'string',
            sendOrgCultureInform: 'boolean',
            targetUserList: { 'type': 'array', 'itemType': DeductionPointBatchRequestTargetUserList },
            userId: 'string',
        };
    }
}
exports.DeductionPointBatchRequest = DeductionPointBatchRequest;
class DeductionPointBatchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: DeductionPointBatchResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.DeductionPointBatchResponseBody = DeductionPointBatchResponseBody;
class DeductionPointBatchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeductionPointBatchResponseBody,
        };
    }
}
exports.DeductionPointBatchResponse = DeductionPointBatchResponse;
class ExportPointOpenHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ExportPointOpenHeaders = ExportPointOpenHeaders;
class ExportPointOpenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            exportDate: 'exportDate',
            exportType: 'exportType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            exportDate: 'string',
            exportType: 'number',
            userId: 'string',
        };
    }
}
exports.ExportPointOpenRequest = ExportPointOpenRequest;
class ExportPointOpenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: 'boolean',
            success: 'boolean',
        };
    }
}
exports.ExportPointOpenResponseBody = ExportPointOpenResponseBody;
class ExportPointOpenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ExportPointOpenResponseBody,
        };
    }
}
exports.ExportPointOpenResponse = ExportPointOpenResponse;
class GrantHonorHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GrantHonorHeaders = GrantHonorHeaders;
class GrantHonorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationTime: 'expirationTime',
            grantReason: 'grantReason',
            granterName: 'granterName',
            noticeAnnouncer: 'noticeAnnouncer',
            noticeSingle: 'noticeSingle',
            receiverUserIds: 'receiverUserIds',
            senderUserId: 'senderUserId',
        };
    }
    static types() {
        return {
            expirationTime: 'number',
            grantReason: 'string',
            granterName: 'string',
            noticeAnnouncer: 'boolean',
            noticeSingle: 'boolean',
            receiverUserIds: { 'type': 'array', 'itemType': 'string' },
            senderUserId: 'string',
        };
    }
}
exports.GrantHonorRequest = GrantHonorRequest;
class GrantHonorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: GrantHonorResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.GrantHonorResponseBody = GrantHonorResponseBody;
class GrantHonorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GrantHonorResponseBody,
        };
    }
}
exports.GrantHonorResponse = GrantHonorResponse;
class QueryCorpPointsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCorpPointsHeaders = QueryCorpPointsHeaders;
class QueryCorpPointsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            optUserId: 'optUserId',
        };
    }
    static types() {
        return {
            optUserId: 'string',
        };
    }
}
exports.QueryCorpPointsRequest = QueryCorpPointsRequest;
class QueryCorpPointsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryCorpPointsResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryCorpPointsResponseBody = QueryCorpPointsResponseBody;
class QueryCorpPointsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryCorpPointsResponseBody,
        };
    }
}
exports.QueryCorpPointsResponse = QueryCorpPointsResponse;
class QueryEmpPointDetailsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryEmpPointDetailsHeaders = QueryEmpPointDetailsHeaders;
class QueryEmpPointDetailsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            userId: 'userId',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            userId: 'string',
        };
    }
}
exports.QueryEmpPointDetailsRequest = QueryEmpPointDetailsRequest;
class QueryEmpPointDetailsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryEmpPointDetailsResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryEmpPointDetailsResponseBody = QueryEmpPointDetailsResponseBody;
class QueryEmpPointDetailsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryEmpPointDetailsResponseBody,
        };
    }
}
exports.QueryEmpPointDetailsResponse = QueryEmpPointDetailsResponse;
class QueryOrgHonorsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryOrgHonorsHeaders = QueryOrgHonorsHeaders;
class QueryOrgHonorsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.QueryOrgHonorsRequest = QueryOrgHonorsRequest;
class QueryOrgHonorsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryOrgHonorsResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryOrgHonorsResponseBody = QueryOrgHonorsResponseBody;
class QueryOrgHonorsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryOrgHonorsResponseBody,
        };
    }
}
exports.QueryOrgHonorsResponse = QueryOrgHonorsResponse;
class QueryOrgPointDetailsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryOrgPointDetailsHeaders = QueryOrgPointDetailsHeaders;
class QueryOrgPointDetailsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountType: 'accountType',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountType: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            userId: 'string',
        };
    }
}
exports.QueryOrgPointDetailsRequest = QueryOrgPointDetailsRequest;
class QueryOrgPointDetailsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: QueryOrgPointDetailsResponseBodyResult,
        };
    }
}
exports.QueryOrgPointDetailsResponseBody = QueryOrgPointDetailsResponseBody;
class QueryOrgPointDetailsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryOrgPointDetailsResponseBody,
        };
    }
}
exports.QueryOrgPointDetailsResponse = QueryOrgPointDetailsResponse;
class QueryPointActionAutoAssignRuleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryPointActionAutoAssignRuleHeaders = QueryPointActionAutoAssignRuleHeaders;
class QueryPointActionAutoAssignRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryPointActionAutoAssignRuleResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryPointActionAutoAssignRuleResponseBody = QueryPointActionAutoAssignRuleResponseBody;
class QueryPointActionAutoAssignRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryPointActionAutoAssignRuleResponseBody,
        };
    }
}
exports.QueryPointActionAutoAssignRuleResponse = QueryPointActionAutoAssignRuleResponse;
class QueryPointAutoIssueSettingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryPointAutoIssueSettingHeaders = QueryPointAutoIssueSettingHeaders;
class QueryPointAutoIssueSettingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryPointAutoIssueSettingResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryPointAutoIssueSettingResponseBody = QueryPointAutoIssueSettingResponseBody;
class QueryPointAutoIssueSettingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryPointAutoIssueSettingResponseBody,
        };
    }
}
exports.QueryPointAutoIssueSettingResponse = QueryPointAutoIssueSettingResponse;
class QueryUserHonorsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryUserHonorsHeaders = QueryUserHonorsHeaders;
class QueryUserHonorsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.QueryUserHonorsRequest = QueryUserHonorsRequest;
class QueryUserHonorsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryUserHonorsResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryUserHonorsResponseBody = QueryUserHonorsResponseBody;
class QueryUserHonorsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryUserHonorsResponseBody,
        };
    }
}
exports.QueryUserHonorsResponse = QueryUserHonorsResponse;
class QueryUserPointsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryUserPointsHeaders = QueryUserPointsHeaders;
class QueryUserPointsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryUserPointsResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryUserPointsResponseBody = QueryUserPointsResponseBody;
class QueryUserPointsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryUserPointsResponseBody,
        };
    }
}
exports.QueryUserPointsResponse = QueryUserPointsResponse;
class UpdateAutoIssuePointHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateAutoIssuePointHeaders = UpdateAutoIssuePointHeaders;
class UpdateAutoIssuePointRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pointAutoNum: 'pointAutoNum',
            pointAutoState: 'pointAutoState',
            pointAutoTime: 'pointAutoTime',
            userId: 'userId',
        };
    }
    static types() {
        return {
            pointAutoNum: 'number',
            pointAutoState: 'boolean',
            pointAutoTime: 'number',
            userId: 'string',
        };
    }
}
exports.UpdateAutoIssuePointRequest = UpdateAutoIssuePointRequest;
class UpdateAutoIssuePointResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: UpdateAutoIssuePointResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.UpdateAutoIssuePointResponseBody = UpdateAutoIssuePointResponseBody;
class UpdateAutoIssuePointResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateAutoIssuePointResponseBody,
        };
    }
}
exports.UpdateAutoIssuePointResponse = UpdateAutoIssuePointResponse;
class UpdatePointActionAutoAssignRuleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdatePointActionAutoAssignRuleHeaders = UpdatePointActionAutoAssignRuleHeaders;
class UpdatePointActionAutoAssignRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            updatePointRuleRequestDTOList: 'updatePointRuleRequestDTOList',
            userId: 'userId',
        };
    }
    static types() {
        return {
            updatePointRuleRequestDTOList: { 'type': 'array', 'itemType': UpdatePointActionAutoAssignRuleRequestUpdatePointRuleRequestDTOList },
            userId: 'string',
        };
    }
}
exports.UpdatePointActionAutoAssignRuleRequest = UpdatePointActionAutoAssignRuleRequest;
class UpdatePointActionAutoAssignRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdatePointActionAutoAssignRuleResponseBody = UpdatePointActionAutoAssignRuleResponseBody;
class UpdatePointActionAutoAssignRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdatePointActionAutoAssignRuleResponseBody,
        };
    }
}
exports.UpdatePointActionAutoAssignRuleResponse = UpdatePointActionAutoAssignRuleResponse;
class AssignOrgHoldingToEmpHoldingBatchRequestTargetUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            outId: 'outId',
            targetUserId: 'targetUserId',
        };
    }
    static types() {
        return {
            outId: 'string',
            targetUserId: 'string',
        };
    }
}
exports.AssignOrgHoldingToEmpHoldingBatchRequestTargetUserList = AssignOrgHoldingToEmpHoldingBatchRequestTargetUserList;
class AssignOrgHoldingToEmpHoldingBatchResponseBodyResultOpenPointInvokeResultDTOS extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            invokeStatus: 'invokeStatus',
            msg: 'msg',
            outId: 'outId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            code: 'string',
            invokeStatus: 'string',
            msg: 'string',
            outId: 'string',
            userId: 'string',
        };
    }
}
exports.AssignOrgHoldingToEmpHoldingBatchResponseBodyResultOpenPointInvokeResultDTOS = AssignOrgHoldingToEmpHoldingBatchResponseBodyResultOpenPointInvokeResultDTOS;
class AssignOrgHoldingToEmpHoldingBatchResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openPointInvokeResultDTOS: 'openPointInvokeResultDTOS',
        };
    }
    static types() {
        return {
            openPointInvokeResultDTOS: { 'type': 'array', 'itemType': AssignOrgHoldingToEmpHoldingBatchResponseBodyResultOpenPointInvokeResultDTOS },
        };
    }
}
exports.AssignOrgHoldingToEmpHoldingBatchResponseBodyResult = AssignOrgHoldingToEmpHoldingBatchResponseBodyResult;
class ConsumeUserPointsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
        };
    }
    static types() {
        return {
            amount: 'number',
        };
    }
}
exports.ConsumeUserPointsResponseBodyResult = ConsumeUserPointsResponseBodyResult;
class DeductionPointBatchRequestTargetUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            outId: 'outId',
            targetUserId: 'targetUserId',
        };
    }
    static types() {
        return {
            outId: 'string',
            targetUserId: 'string',
        };
    }
}
exports.DeductionPointBatchRequestTargetUserList = DeductionPointBatchRequestTargetUserList;
class DeductionPointBatchResponseBodyResultOpenPointInvokeResultDTOS extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            invokeStatus: 'invokeStatus',
            msg: 'msg',
            outId: 'outId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            code: 'string',
            invokeStatus: 'string',
            msg: 'string',
            outId: 'string',
            userId: 'string',
        };
    }
}
exports.DeductionPointBatchResponseBodyResultOpenPointInvokeResultDTOS = DeductionPointBatchResponseBodyResultOpenPointInvokeResultDTOS;
class DeductionPointBatchResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openPointInvokeResultDTOS: 'openPointInvokeResultDTOS',
        };
    }
    static types() {
        return {
            openPointInvokeResultDTOS: { 'type': 'array', 'itemType': DeductionPointBatchResponseBodyResultOpenPointInvokeResultDTOS },
        };
    }
}
exports.DeductionPointBatchResponseBodyResult = DeductionPointBatchResponseBodyResult;
class GrantHonorResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedUserIds: 'failedUserIds',
            successUserIds: 'successUserIds',
        };
    }
    static types() {
        return {
            failedUserIds: { 'type': 'array', 'itemType': 'string' },
            successUserIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GrantHonorResponseBodyResult = GrantHonorResponseBodyResult;
class QueryCorpPointsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
        };
    }
    static types() {
        return {
            amount: 'number',
        };
    }
}
exports.QueryCorpPointsResponseBodyResult = QueryCorpPointsResponseBodyResult;
class QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountType: 'accountType',
            empName: 'empName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountType: 'string',
            empName: 'string',
            userId: 'string',
        };
    }
}
exports.QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource = QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource;
class QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountType: 'accountType',
            empName: 'empName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountType: 'string',
            empName: 'string',
            userId: 'string',
        };
    }
}
exports.QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget = QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget;
class QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountSource: 'accountSource',
            accountTarget: 'accountTarget',
            remark: 'remark',
            usage: 'usage',
        };
    }
    static types() {
        return {
            accountSource: QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource,
            accountTarget: QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget,
            remark: 'string',
            usage: 'string',
        };
    }
}
exports.QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO = QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO;
class QueryEmpPointDetailsResponseBodyResultDetails extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            gmtCreate: 'gmtCreate',
            outId: 'outId',
            pointOperateFeatureResponseDTO: 'pointOperateFeatureResponseDTO',
            sourceBizCode: 'sourceBizCode',
        };
    }
    static types() {
        return {
            amount: 'number',
            gmtCreate: 'number',
            outId: 'string',
            pointOperateFeatureResponseDTO: QueryEmpPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO,
            sourceBizCode: 'string',
        };
    }
}
exports.QueryEmpPointDetailsResponseBodyResultDetails = QueryEmpPointDetailsResponseBodyResultDetails;
class QueryEmpPointDetailsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            details: 'details',
            hasMore: 'hasMore',
        };
    }
    static types() {
        return {
            details: { 'type': 'array', 'itemType': QueryEmpPointDetailsResponseBodyResultDetails },
            hasMore: 'boolean',
        };
    }
}
exports.QueryEmpPointDetailsResponseBodyResult = QueryEmpPointDetailsResponseBodyResult;
class QueryOrgHonorsResponseBodyResultOpenHonors extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            honorDesc: 'honorDesc',
            honorId: 'honorId',
            honorImgUrl: 'honorImgUrl',
            honorName: 'honorName',
            honorPendantImgUrl: 'honorPendantImgUrl',
        };
    }
    static types() {
        return {
            honorDesc: 'string',
            honorId: 'number',
            honorImgUrl: 'string',
            honorName: 'string',
            honorPendantImgUrl: 'string',
        };
    }
}
exports.QueryOrgHonorsResponseBodyResultOpenHonors = QueryOrgHonorsResponseBodyResultOpenHonors;
class QueryOrgHonorsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            openHonors: 'openHonors',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            openHonors: { 'type': 'array', 'itemType': QueryOrgHonorsResponseBodyResultOpenHonors },
        };
    }
}
exports.QueryOrgHonorsResponseBodyResult = QueryOrgHonorsResponseBodyResult;
class QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountType: 'accountType',
            empName: 'empName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountType: 'string',
            empName: 'string',
            userId: 'string',
        };
    }
}
exports.QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource = QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource;
class QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountType: 'accountType',
            empName: 'empName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            accountType: 'string',
            empName: 'string',
            userId: 'string',
        };
    }
}
exports.QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget = QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget;
class QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountSource: 'accountSource',
            accountTarget: 'accountTarget',
            remark: 'remark',
            usage: 'usage',
        };
    }
    static types() {
        return {
            accountSource: QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountSource,
            accountTarget: QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTOAccountTarget,
            remark: 'string',
            usage: 'string',
        };
    }
}
exports.QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO = QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO;
class QueryOrgPointDetailsResponseBodyResultDetails extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            gmtCreate: 'gmtCreate',
            outId: 'outId',
            pointOperateFeatureResponseDTO: 'pointOperateFeatureResponseDTO',
            sourceBizCode: 'sourceBizCode',
        };
    }
    static types() {
        return {
            amount: 'number',
            gmtCreate: 'number',
            outId: 'string',
            pointOperateFeatureResponseDTO: QueryOrgPointDetailsResponseBodyResultDetailsPointOperateFeatureResponseDTO,
            sourceBizCode: 'string',
        };
    }
}
exports.QueryOrgPointDetailsResponseBodyResultDetails = QueryOrgPointDetailsResponseBodyResultDetails;
class QueryOrgPointDetailsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            details: 'details',
            hasMore: 'hasMore',
            success: 'success',
        };
    }
    static types() {
        return {
            details: { 'type': 'array', 'itemType': QueryOrgPointDetailsResponseBodyResultDetails },
            hasMore: 'boolean',
            success: 'boolean',
        };
    }
}
exports.QueryOrgPointDetailsResponseBodyResult = QueryOrgPointDetailsResponseBodyResult;
class QueryPointActionAutoAssignRuleResponseBodyResultQueryPointRuleResponseDTOS extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            awardScore: 'awardScore',
            code: 'code',
            dayLimitTimes: 'dayLimitTimes',
            description: 'description',
            status: 'status',
        };
    }
    static types() {
        return {
            awardScore: 'number',
            code: 'string',
            dayLimitTimes: 'number',
            description: 'string',
            status: 'number',
        };
    }
}
exports.QueryPointActionAutoAssignRuleResponseBodyResultQueryPointRuleResponseDTOS = QueryPointActionAutoAssignRuleResponseBodyResultQueryPointRuleResponseDTOS;
class QueryPointActionAutoAssignRuleResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            queryPointRuleResponseDTOS: 'queryPointRuleResponseDTOS',
        };
    }
    static types() {
        return {
            queryPointRuleResponseDTOS: { 'type': 'array', 'itemType': QueryPointActionAutoAssignRuleResponseBodyResultQueryPointRuleResponseDTOS },
        };
    }
}
exports.QueryPointActionAutoAssignRuleResponseBodyResult = QueryPointActionAutoAssignRuleResponseBodyResult;
class QueryPointAutoIssueSettingResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pointAutoNum: 'pointAutoNum',
            pointAutoState: 'pointAutoState',
            pointAutoTime: 'pointAutoTime',
        };
    }
    static types() {
        return {
            pointAutoNum: 'number',
            pointAutoState: 'boolean',
            pointAutoTime: 'number',
        };
    }
}
exports.QueryPointAutoIssueSettingResponseBodyResult = QueryPointAutoIssueSettingResponseBodyResult;
class QueryUserHonorsResponseBodyResultHonorsGrantHistory extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            grantTime: 'grantTime',
            senderUserid: 'senderUserid',
        };
    }
    static types() {
        return {
            grantTime: 'number',
            senderUserid: 'string',
        };
    }
}
exports.QueryUserHonorsResponseBodyResultHonorsGrantHistory = QueryUserHonorsResponseBodyResultHonorsGrantHistory;
class QueryUserHonorsResponseBodyResultHonors extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationTime: 'expirationTime',
            grantHistory: 'grantHistory',
            honorDesc: 'honorDesc',
            honorId: 'honorId',
            honorName: 'honorName',
        };
    }
    static types() {
        return {
            expirationTime: 'number',
            grantHistory: { 'type': 'array', 'itemType': QueryUserHonorsResponseBodyResultHonorsGrantHistory },
            honorDesc: 'string',
            honorId: 'string',
            honorName: 'string',
        };
    }
}
exports.QueryUserHonorsResponseBodyResultHonors = QueryUserHonorsResponseBodyResultHonors;
class QueryUserHonorsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            honors: 'honors',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            honors: { 'type': 'array', 'itemType': QueryUserHonorsResponseBodyResultHonors },
            nextToken: 'string',
        };
    }
}
exports.QueryUserHonorsResponseBodyResult = QueryUserHonorsResponseBodyResult;
class QueryUserPointsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
        };
    }
    static types() {
        return {
            amount: 'number',
        };
    }
}
exports.QueryUserPointsResponseBodyResult = QueryUserPointsResponseBodyResult;
class UpdateAutoIssuePointResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextAutoIssuePointTime: 'nextAutoIssuePointTime',
        };
    }
    static types() {
        return {
            nextAutoIssuePointTime: 'number',
        };
    }
}
exports.UpdateAutoIssuePointResponseBodyResult = UpdateAutoIssuePointResponseBodyResult;
class UpdatePointActionAutoAssignRuleRequestUpdatePointRuleRequestDTOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            awardScore: 'awardScore',
            code: 'code',
            dayLimitTimes: 'dayLimitTimes',
            status: 'status',
        };
    }
    static types() {
        return {
            awardScore: 'number',
            code: 'string',
            dayLimitTimes: 'number',
            status: 'number',
        };
    }
}
exports.UpdatePointActionAutoAssignRuleRequestUpdatePointRuleRequestDTOList = UpdatePointActionAutoAssignRuleRequestUpdatePointRuleRequestDTOList;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async assignOrgHoldingToEmpHoldingBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AssignOrgHoldingToEmpHoldingBatchHeaders({});
        return await this.assignOrgHoldingToEmpHoldingBatchWithOptions(request, headers, runtime);
    }
    async assignOrgHoldingToEmpHoldingBatchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.sendOrgCultureInform)) {
            body["sendOrgCultureInform"] = request.sendOrgCultureInform;
        }
        if (!tea_util_1.default.isUnset(request.singleAmount)) {
            body["singleAmount"] = request.singleAmount;
        }
        if (!tea_util_1.default.isUnset(request.sourceUsage)) {
            body["sourceUsage"] = request.sourceUsage;
        }
        if (!tea_util_1.default.isUnset(request.targetUsage)) {
            body["targetUsage"] = request.targetUsage;
        }
        if (!tea_util_1.default.isUnset(request.targetUserList)) {
            body["targetUserList"] = request.targetUserList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AssignOrgHoldingToEmpHoldingBatch", "orgCulture_1.0", "HTTP", "POST", "AK", `/v1.0/orgCulture/organizations/points/assign`, "json", req, runtime), new AssignOrgHoldingToEmpHoldingBatchResponse({}));
    }
    async consumeUserPoints(userId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ConsumeUserPointsHeaders({});
        return await this.consumeUserPointsWithOptions(userId, request, headers, runtime);
    }
    async consumeUserPointsWithOptions(userId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.amount)) {
            body["amount"] = request.amount;
        }
        if (!tea_util_1.default.isUnset(request.outId)) {
            body["outId"] = request.outId;
        }
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.usage)) {
            body["usage"] = request.usage;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ConsumeUserPoints", "orgCulture_1.0", "HTTP", "POST", "AK", `/v1.0/orgCulture/users/${userId}/points/deduct`, "json", req, runtime), new ConsumeUserPointsResponse({}));
    }
    async deductionPointBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeductionPointBatchHeaders({});
        return await this.deductionPointBatchWithOptions(request, headers, runtime);
    }
    async deductionPointBatchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deductionAmount)) {
            body["deductionAmount"] = request.deductionAmount;
        }
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.sendOrgCultureInform)) {
            body["sendOrgCultureInform"] = request.sendOrgCultureInform;
        }
        if (!tea_util_1.default.isUnset(request.targetUserList)) {
            body["targetUserList"] = request.targetUserList;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("DeductionPointBatch", "orgCulture_1.0", "HTTP", "POST", "AK", `/v1.0/orgCulture/users/points/deduct`, "json", req, runtime), new DeductionPointBatchResponse({}));
    }
    async exportPointOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ExportPointOpenHeaders({});
        return await this.exportPointOpenWithOptions(request, headers, runtime);
    }
    async exportPointOpenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.exportDate)) {
            body["exportDate"] = request.exportDate;
        }
        if (!tea_util_1.default.isUnset(request.exportType)) {
            body["exportType"] = request.exportType;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ExportPointOpen", "orgCulture_1.0", "HTTP", "POST", "AK", `/v1.0/orgCulture/users/points/export`, "json", req, runtime), new ExportPointOpenResponse({}));
    }
    async grantHonor(honorId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GrantHonorHeaders({});
        return await this.grantHonorWithOptions(honorId, request, headers, runtime);
    }
    async grantHonorWithOptions(honorId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        honorId = openapi_util_1.default.getEncodeParam(honorId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.expirationTime)) {
            body["expirationTime"] = request.expirationTime;
        }
        if (!tea_util_1.default.isUnset(request.grantReason)) {
            body["grantReason"] = request.grantReason;
        }
        if (!tea_util_1.default.isUnset(request.granterName)) {
            body["granterName"] = request.granterName;
        }
        if (!tea_util_1.default.isUnset(request.noticeAnnouncer)) {
            body["noticeAnnouncer"] = request.noticeAnnouncer;
        }
        if (!tea_util_1.default.isUnset(request.noticeSingle)) {
            body["noticeSingle"] = request.noticeSingle;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIds)) {
            body["receiverUserIds"] = request.receiverUserIds;
        }
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            body["senderUserId"] = request.senderUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GrantHonor", "orgCulture_1.0", "HTTP", "POST", "AK", `/v1.0/orgCulture/honors/${honorId}/grant`, "json", req, runtime), new GrantHonorResponse({}));
    }
    async queryCorpPoints(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCorpPointsHeaders({});
        return await this.queryCorpPointsWithOptions(request, headers, runtime);
    }
    async queryCorpPointsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            query["optUserId"] = request.optUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryCorpPoints", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/organizations/points`, "json", req, runtime), new QueryCorpPointsResponse({}));
    }
    async queryEmpPointDetails(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryEmpPointDetailsHeaders({});
        return await this.queryEmpPointDetailsWithOptions(request, headers, runtime);
    }
    async queryEmpPointDetailsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryEmpPointDetails", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/points/empDetails`, "json", req, runtime), new QueryEmpPointDetailsResponse({}));
    }
    async queryOrgHonors(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryOrgHonorsHeaders({});
        return await this.queryOrgHonorsWithOptions(request, headers, runtime);
    }
    async queryOrgHonorsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryOrgHonors", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/organizations/honors`, "json", req, runtime), new QueryOrgHonorsResponse({}));
    }
    async queryOrgPointDetails(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryOrgPointDetailsHeaders({});
        return await this.queryOrgPointDetailsWithOptions(request, headers, runtime);
    }
    async queryOrgPointDetailsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountType)) {
            query["accountType"] = request.accountType;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryOrgPointDetails", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/points/orgDetails`, "json", req, runtime), new QueryOrgPointDetailsResponse({}));
    }
    async queryPointActionAutoAssignRule() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryPointActionAutoAssignRuleHeaders({});
        return await this.queryPointActionAutoAssignRuleWithOptions(headers, runtime);
    }
    async queryPointActionAutoAssignRuleWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("QueryPointActionAutoAssignRule", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/users/points/actionRules`, "json", req, runtime), new QueryPointActionAutoAssignRuleResponse({}));
    }
    async queryPointAutoIssueSetting() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryPointAutoIssueSettingHeaders({});
        return await this.queryPointAutoIssueSettingWithOptions(headers, runtime);
    }
    async queryPointAutoIssueSettingWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("QueryPointAutoIssueSetting", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/users/points`, "json", req, runtime), new QueryPointAutoIssueSettingResponse({}));
    }
    async queryUserHonors(userId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUserHonorsHeaders({});
        return await this.queryUserHonorsWithOptions(userId, request, headers, runtime);
    }
    async queryUserHonorsWithOptions(userId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryUserHonors", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/honors/users/${userId}`, "json", req, runtime), new QueryUserHonorsResponse({}));
    }
    async queryUserPoints(userId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUserPointsHeaders({});
        return await this.queryUserPointsWithOptions(userId, headers, runtime);
    }
    async queryUserPointsWithOptions(userId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("QueryUserPoints", "orgCulture_1.0", "HTTP", "GET", "AK", `/v1.0/orgCulture/users/${userId}/points`, "json", req, runtime), new QueryUserPointsResponse({}));
    }
    async updateAutoIssuePoint(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateAutoIssuePointHeaders({});
        return await this.updateAutoIssuePointWithOptions(request, headers, runtime);
    }
    async updateAutoIssuePointWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.pointAutoNum)) {
            body["pointAutoNum"] = request.pointAutoNum;
        }
        if (!tea_util_1.default.isUnset(request.pointAutoState)) {
            body["pointAutoState"] = request.pointAutoState;
        }
        if (!tea_util_1.default.isUnset(request.pointAutoTime)) {
            body["pointAutoTime"] = request.pointAutoTime;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateAutoIssuePoint", "orgCulture_1.0", "HTTP", "POST", "AK", `/v1.0/orgCulture/users/points/set`, "json", req, runtime), new UpdateAutoIssuePointResponse({}));
    }
    async updatePointActionAutoAssignRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdatePointActionAutoAssignRuleHeaders({});
        return await this.updatePointActionAutoAssignRuleWithOptions(request, headers, runtime);
    }
    async updatePointActionAutoAssignRuleWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.updatePointRuleRequestDTOList)) {
            body["updatePointRuleRequestDTOList"] = request.updatePointRuleRequestDTOList;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdatePointActionAutoAssignRule", "orgCulture_1.0", "HTTP", "PUT", "AK", `/v1.0/orgCulture/users/points/actionRules`, "json", req, runtime), new UpdatePointActionAutoAssignRuleResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map