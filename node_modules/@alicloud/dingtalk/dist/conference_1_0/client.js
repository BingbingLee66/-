"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class CloseVideoConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CloseVideoConferenceHeaders = CloseVideoConferenceHeaders;
class CloseVideoConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.CloseVideoConferenceRequest = CloseVideoConferenceRequest;
class CloseVideoConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cause: 'cause',
            code: 'code',
        };
    }
    static types() {
        return {
            cause: 'string',
            code: 'number',
        };
    }
}
exports.CloseVideoConferenceResponseBody = CloseVideoConferenceResponseBody;
class CloseVideoConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CloseVideoConferenceResponseBody,
        };
    }
}
exports.CloseVideoConferenceResponse = CloseVideoConferenceResponse;
class CreateVideoConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateVideoConferenceHeaders = CreateVideoConferenceHeaders;
class CreateVideoConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confTitle: 'confTitle',
            inviteCaller: 'inviteCaller',
            inviteUserIds: 'inviteUserIds',
            userId: 'userId',
        };
    }
    static types() {
        return {
            confTitle: 'string',
            inviteCaller: 'boolean',
            inviteUserIds: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
}
exports.CreateVideoConferenceRequest = CreateVideoConferenceRequest;
class CreateVideoConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            conferencePassword: 'conferencePassword',
            externalLinkUrl: 'externalLinkUrl',
            hostPassword: 'hostPassword',
            phoneNumbers: 'phoneNumbers',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            conferencePassword: 'string',
            externalLinkUrl: 'string',
            hostPassword: 'string',
            phoneNumbers: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.CreateVideoConferenceResponseBody = CreateVideoConferenceResponseBody;
class CreateVideoConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateVideoConferenceResponseBody,
        };
    }
}
exports.CreateVideoConferenceResponse = CreateVideoConferenceResponse;
class QueryCloudRecordTextHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCloudRecordTextHeaders = QueryCloudRecordTextHeaders;
class QueryCloudRecordTextRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            direction: 'direction',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            direction: 'string',
            maxResults: 'number',
            nextToken: 'number',
            startTime: 'number',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordTextRequest = QueryCloudRecordTextRequest;
class QueryCloudRecordTextResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            paragraphList: 'paragraphList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            paragraphList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphList },
        };
    }
}
exports.QueryCloudRecordTextResponseBody = QueryCloudRecordTextResponseBody;
class QueryCloudRecordTextResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryCloudRecordTextResponseBody,
        };
    }
}
exports.QueryCloudRecordTextResponse = QueryCloudRecordTextResponse;
class QueryCloudRecordVideoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCloudRecordVideoHeaders = QueryCloudRecordVideoHeaders;
class QueryCloudRecordVideoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordVideoRequest = QueryCloudRecordVideoRequest;
class QueryCloudRecordVideoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            videoList: 'videoList',
        };
    }
    static types() {
        return {
            videoList: { 'type': 'array', 'itemType': QueryCloudRecordVideoResponseBodyVideoList },
        };
    }
}
exports.QueryCloudRecordVideoResponseBody = QueryCloudRecordVideoResponseBody;
class QueryCloudRecordVideoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryCloudRecordVideoResponseBody,
        };
    }
}
exports.QueryCloudRecordVideoResponse = QueryCloudRecordVideoResponse;
class QueryCloudRecordVideoPlayInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoHeaders = QueryCloudRecordVideoPlayInfoHeaders;
class QueryCloudRecordVideoPlayInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mediaId: 'mediaId',
            regionId: 'regionId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mediaId: 'string',
            regionId: 'string',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoRequest = QueryCloudRecordVideoPlayInfoRequest;
class QueryCloudRecordVideoPlayInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            fileSize: 'fileSize',
            mp4FileUrl: 'mp4FileUrl',
            playUrl: 'playUrl',
            status: 'status',
        };
    }
    static types() {
        return {
            duration: 'number',
            fileSize: 'number',
            mp4FileUrl: 'string',
            playUrl: 'string',
            status: 'number',
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoResponseBody = QueryCloudRecordVideoPlayInfoResponseBody;
class QueryCloudRecordVideoPlayInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryCloudRecordVideoPlayInfoResponseBody,
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoResponse = QueryCloudRecordVideoPlayInfoResponse;
class QueryConferenceInfoBatchHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryConferenceInfoBatchHeaders = QueryConferenceInfoBatchHeaders;
class QueryConferenceInfoBatchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceIdList: 'conferenceIdList',
        };
    }
    static types() {
        return {
            conferenceIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryConferenceInfoBatchRequest = QueryConferenceInfoBatchRequest;
class QueryConferenceInfoBatchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            infos: 'infos',
        };
    }
    static types() {
        return {
            infos: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfos },
        };
    }
}
exports.QueryConferenceInfoBatchResponseBody = QueryConferenceInfoBatchResponseBody;
class QueryConferenceInfoBatchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryConferenceInfoBatchResponseBody,
        };
    }
}
exports.QueryConferenceInfoBatchResponse = QueryConferenceInfoBatchResponse;
class StartCloudRecordHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StartCloudRecordHeaders = StartCloudRecordHeaders;
class StartCloudRecordRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mode: 'mode',
            smallWindowPosition: 'smallWindowPosition',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            smallWindowPosition: 'string',
            unionId: 'string',
        };
    }
}
exports.StartCloudRecordRequest = StartCloudRecordRequest;
class StartCloudRecordResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
}
exports.StartCloudRecordResponseBody = StartCloudRecordResponseBody;
class StartCloudRecordResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: StartCloudRecordResponseBody,
        };
    }
}
exports.StartCloudRecordResponse = StartCloudRecordResponse;
class StartStreamOutHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StartStreamOutHeaders = StartStreamOutHeaders;
class StartStreamOutRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mode: 'mode',
            needHostJoin: 'needHostJoin',
            smallWindowPosition: 'smallWindowPosition',
            streamName: 'streamName',
            streamUrlList: 'streamUrlList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            needHostJoin: 'boolean',
            smallWindowPosition: 'string',
            streamName: 'string',
            streamUrlList: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.StartStreamOutRequest = StartStreamOutRequest;
class StartStreamOutResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failStreamMap: 'failStreamMap',
            successStreamMap: 'successStreamMap',
        };
    }
    static types() {
        return {
            failStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            successStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.StartStreamOutResponseBody = StartStreamOutResponseBody;
class StartStreamOutResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: StartStreamOutResponseBody,
        };
    }
}
exports.StartStreamOutResponse = StartStreamOutResponse;
class StopCloudRecordHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StopCloudRecordHeaders = StopCloudRecordHeaders;
class StopCloudRecordRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.StopCloudRecordRequest = StopCloudRecordRequest;
class StopCloudRecordResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
}
exports.StopCloudRecordResponseBody = StopCloudRecordResponseBody;
class StopCloudRecordResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: StopCloudRecordResponseBody,
        };
    }
}
exports.StopCloudRecordResponse = StopCloudRecordResponse;
class StopStreamOutHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StopStreamOutHeaders = StopStreamOutHeaders;
class StopStreamOutRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            stopAllStream: 'stopAllStream',
            streamId: 'streamId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            stopAllStream: 'boolean',
            streamId: 'string',
            unionId: 'string',
        };
    }
}
exports.StopStreamOutRequest = StopStreamOutRequest;
class StopStreamOutResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
}
exports.StopStreamOutResponseBody = StopStreamOutResponseBody;
class StopStreamOutResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: StopStreamOutResponseBody,
        };
    }
}
exports.StopStreamOutResponse = StopStreamOutResponse;
class UpdateVideoConferenceExtInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateVideoConferenceExtInfoHeaders = UpdateVideoConferenceExtInfoHeaders;
class UpdateVideoConferenceExtInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
}
exports.UpdateVideoConferenceExtInfoResponseBody = UpdateVideoConferenceExtInfoResponseBody;
class UpdateVideoConferenceExtInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateVideoConferenceExtInfoResponseBody,
        };
    }
}
exports.UpdateVideoConferenceExtInfoResponse = UpdateVideoConferenceExtInfoResponse;
class UpdateVideoConferenceSettingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateVideoConferenceSettingHeaders = UpdateVideoConferenceSettingHeaders;
class UpdateVideoConferenceSettingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allowUnmuteSelf: 'allowUnmuteSelf',
            autoTransferHost: 'autoTransferHost',
            forbiddenShareScreen: 'forbiddenShareScreen',
            lockConference: 'lockConference',
            muteAll: 'muteAll',
            onlyInternalEmployeesJoin: 'onlyInternalEmployeesJoin',
        };
    }
    static types() {
        return {
            allowUnmuteSelf: 'boolean',
            autoTransferHost: 'boolean',
            forbiddenShareScreen: 'boolean',
            lockConference: 'boolean',
            muteAll: 'boolean',
            onlyInternalEmployeesJoin: 'boolean',
        };
    }
}
exports.UpdateVideoConferenceSettingRequest = UpdateVideoConferenceSettingRequest;
class UpdateVideoConferenceSettingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
}
exports.UpdateVideoConferenceSettingResponseBody = UpdateVideoConferenceSettingResponseBody;
class UpdateVideoConferenceSettingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateVideoConferenceSettingResponseBody,
        };
    }
}
exports.UpdateVideoConferenceSettingResponse = UpdateVideoConferenceSettingResponse;
class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
            word: 'word',
            wordId: 'wordId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            startTime: 'number',
            word: 'string',
            wordId: 'string',
        };
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList = QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList;
class QueryCloudRecordTextResponseBodyParagraphListSentenceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            sentence: 'sentence',
            startTime: 'startTime',
            unionId: 'unionId',
            wordList: 'wordList',
        };
    }
    static types() {
        return {
            endTime: 'number',
            sentence: 'string',
            startTime: 'number',
            unionId: 'string',
            wordList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList },
        };
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceList = QueryCloudRecordTextResponseBodyParagraphListSentenceList;
class QueryCloudRecordTextResponseBodyParagraphList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            nextTtoken: 'nextTtoken',
            nickName: 'nickName',
            paragraph: 'paragraph',
            recordId: 'recordId',
            sentenceList: 'sentenceList',
            startTime: 'startTime',
            status: 'status',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            nextTtoken: 'number',
            nickName: 'string',
            paragraph: 'string',
            recordId: 'number',
            sentenceList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceList },
            startTime: 'number',
            status: 'number',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphList = QueryCloudRecordTextResponseBodyParagraphList;
class QueryCloudRecordVideoResponseBodyVideoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            endTime: 'endTime',
            fileSize: 'fileSize',
            mediaId: 'mediaId',
            recordId: 'recordId',
            recordType: 'recordType',
            regionId: 'regionId',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            duration: 'number',
            endTime: 'number',
            fileSize: 'number',
            mediaId: 'string',
            recordId: 'string',
            recordType: 'number',
            regionId: 'string',
            startTime: 'number',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordVideoResponseBodyVideoList = QueryCloudRecordVideoResponseBodyVideoList;
class QueryConferenceInfoBatchResponseBodyInfosUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendStatus: 'attendStatus',
            cameraStatus: 'cameraStatus',
            micStatus: 'micStatus',
            nick: 'nick',
            rejectDescription: 'rejectDescription',
            userId: 'userId',
        };
    }
    static types() {
        return {
            attendStatus: 'number',
            cameraStatus: 'number',
            micStatus: 'number',
            nick: 'string',
            rejectDescription: 'string',
            userId: 'string',
        };
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfosUserList = QueryConferenceInfoBatchResponseBodyInfosUserList;
class QueryConferenceInfoBatchResponseBodyInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            mediaStatus: 'mediaStatus',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
            userList: 'userList',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            mediaStatus: 'number',
            startTime: 'number',
            status: 'number',
            title: 'string',
            userList: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfosUserList },
        };
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfos = QueryConferenceInfoBatchResponseBodyInfos;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async closeVideoConference(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CloseVideoConferenceHeaders({});
        return await this.closeVideoConferenceWithOptions(conferenceId, request, headers, runtime);
    }
    async closeVideoConferenceWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("CloseVideoConference", "conference_1.0", "HTTP", "DELETE", "AK", `/v1.0/conference/videoConferences/${conferenceId}`, "json", req, runtime), new CloseVideoConferenceResponse({}));
    }
    async createVideoConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateVideoConferenceHeaders({});
        return await this.createVideoConferenceWithOptions(request, headers, runtime);
    }
    async createVideoConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.confTitle)) {
            body["confTitle"] = request.confTitle;
        }
        if (!tea_util_1.default.isUnset(request.inviteCaller)) {
            body["inviteCaller"] = request.inviteCaller;
        }
        if (!tea_util_1.default.isUnset(request.inviteUserIds)) {
            body["inviteUserIds"] = request.inviteUserIds;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateVideoConference", "conference_1.0", "HTTP", "POST", "AK", `/v1.0/conference/videoConferences`, "json", req, runtime), new CreateVideoConferenceResponse({}));
    }
    async queryCloudRecordText(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordTextHeaders({});
        return await this.queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime);
    }
    async queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.direction)) {
            query["direction"] = request.direction;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryCloudRecordText", "conference_1.0", "HTTP", "GET", "AK", `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getTexts`, "json", req, runtime), new QueryCloudRecordTextResponse({}));
    }
    async queryCloudRecordVideo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoHeaders({});
        return await this.queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime);
    }
    async queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryCloudRecordVideo", "conference_1.0", "HTTP", "GET", "AK", `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getVideos`, "json", req, runtime), new QueryCloudRecordVideoResponse({}));
    }
    async queryCloudRecordVideoPlayInfo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoPlayInfoHeaders({});
        return await this.queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime);
    }
    async queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            query["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["regionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("QueryCloudRecordVideoPlayInfo", "conference_1.0", "HTTP", "GET", "AK", `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/videos/getPlayInfos`, "json", req, runtime), new QueryCloudRecordVideoPlayInfoResponse({}));
    }
    async queryConferenceInfoBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoBatchHeaders({});
        return await this.queryConferenceInfoBatchWithOptions(request, headers, runtime);
    }
    async queryConferenceInfoBatchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conferenceIdList)) {
            body["conferenceIdList"] = request.conferenceIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("QueryConferenceInfoBatch", "conference_1.0", "HTTP", "POST", "AK", `/v1.0/conference/videoConferences/query`, "json", req, runtime), new QueryConferenceInfoBatchResponse({}));
    }
    async startCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartCloudRecordHeaders({});
        return await this.startCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    async startCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("StartCloudRecord", "conference_1.0", "HTTP", "POST", "AK", `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/start`, "json", req, runtime), new StartCloudRecordResponse({}));
    }
    async startStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartStreamOutHeaders({});
        return await this.startStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    async startStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.needHostJoin)) {
            body["needHostJoin"] = request.needHostJoin;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.streamName)) {
            body["streamName"] = request.streamName;
        }
        if (!tea_util_1.default.isUnset(request.streamUrlList)) {
            body["streamUrlList"] = request.streamUrlList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("StartStreamOut", "conference_1.0", "HTTP", "POST", "AK", `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/start`, "json", req, runtime), new StartStreamOutResponse({}));
    }
    async stopCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopCloudRecordHeaders({});
        return await this.stopCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    async stopCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("StopCloudRecord", "conference_1.0", "HTTP", "POST", "AK", `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/stop`, "json", req, runtime), new StopCloudRecordResponse({}));
    }
    async stopStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopStreamOutHeaders({});
        return await this.stopStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    async stopStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.stopAllStream)) {
            body["stopAllStream"] = request.stopAllStream;
        }
        if (!tea_util_1.default.isUnset(request.streamId)) {
            body["streamId"] = request.streamId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("StopStreamOut", "conference_1.0", "HTTP", "POST", "AK", `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/stop`, "json", req, runtime), new StopStreamOutResponse({}));
    }
    async updateVideoConferenceExtInfo(conferenceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceExtInfoHeaders({});
        return await this.updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime);
    }
    async updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime) {
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("UpdateVideoConferenceExtInfo", "conference_1.0", "HTTP", "PUT", "AK", `/v1.0/conference/videoConferences/${conferenceId}/extInfo`, "json", req, runtime), new UpdateVideoConferenceExtInfoResponse({}));
    }
    async updateVideoConferenceSetting(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceSettingHeaders({});
        return await this.updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime);
    }
    async updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        conferenceId = openapi_util_1.default.getEncodeParam(conferenceId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.allowUnmuteSelf)) {
            body["allowUnmuteSelf"] = request.allowUnmuteSelf;
        }
        if (!tea_util_1.default.isUnset(request.autoTransferHost)) {
            body["autoTransferHost"] = request.autoTransferHost;
        }
        if (!tea_util_1.default.isUnset(request.forbiddenShareScreen)) {
            body["forbiddenShareScreen"] = request.forbiddenShareScreen;
        }
        if (!tea_util_1.default.isUnset(request.lockConference)) {
            body["lockConference"] = request.lockConference;
        }
        if (!tea_util_1.default.isUnset(request.muteAll)) {
            body["muteAll"] = request.muteAll;
        }
        if (!tea_util_1.default.isUnset(request.onlyInternalEmployeesJoin)) {
            body["onlyInternalEmployeesJoin"] = request.onlyInternalEmployeesJoin;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateVideoConferenceSetting", "conference_1.0", "HTTP", "PUT", "AK", `/v1.0/conference/videoConferences/${conferenceId}`, "json", req, runtime), new UpdateVideoConferenceSettingResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map