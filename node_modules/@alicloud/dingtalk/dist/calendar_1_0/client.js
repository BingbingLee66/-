"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddAttendeeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddAttendeeHeaders = AddAttendeeHeaders;
class AddAttendeeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendeesToAdd: 'attendeesToAdd',
        };
    }
    static types() {
        return {
            attendeesToAdd: { 'type': 'array', 'itemType': AddAttendeeRequestAttendeesToAdd },
        };
    }
}
exports.AddAttendeeRequest = AddAttendeeRequest;
class AddAttendeeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.AddAttendeeResponse = AddAttendeeResponse;
class CheckInHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CheckInHeaders = CheckInHeaders;
class CheckInResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkInTime: 'checkInTime',
        };
    }
    static types() {
        return {
            checkInTime: 'number',
        };
    }
}
exports.CheckInResponseBody = CheckInResponseBody;
class CheckInResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CheckInResponseBody,
        };
    }
}
exports.CheckInResponse = CheckInResponse;
class ConvertLegacyEventIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ConvertLegacyEventIdHeaders = ConvertLegacyEventIdHeaders;
class ConvertLegacyEventIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            legacyEventIds: 'legacyEventIds',
        };
    }
    static types() {
        return {
            legacyEventIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ConvertLegacyEventIdRequest = ConvertLegacyEventIdRequest;
class ConvertLegacyEventIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            legacyEventIdMap: 'legacyEventIdMap',
        };
    }
    static types() {
        return {
            legacyEventIdMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.ConvertLegacyEventIdResponseBody = ConvertLegacyEventIdResponseBody;
class ConvertLegacyEventIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ConvertLegacyEventIdResponseBody,
        };
    }
}
exports.ConvertLegacyEventIdResponse = ConvertLegacyEventIdResponse;
class CreateAclsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateAclsHeaders = CreateAclsHeaders;
class CreateAclsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            privilege: 'privilege',
            scope: 'scope',
            sendMsg: 'sendMsg',
        };
    }
    static types() {
        return {
            privilege: 'string',
            scope: CreateAclsRequestScope,
            sendMsg: 'boolean',
        };
    }
}
exports.CreateAclsRequest = CreateAclsRequest;
class CreateAclsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aclId: 'aclId',
            privilege: 'privilege',
            scope: 'scope',
        };
    }
    static types() {
        return {
            aclId: 'string',
            privilege: 'string',
            scope: CreateAclsResponseBodyScope,
        };
    }
}
exports.CreateAclsResponseBody = CreateAclsResponseBody;
class CreateAclsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateAclsResponseBody,
        };
    }
}
exports.CreateAclsResponse = CreateAclsResponse;
class CreateEventHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateEventHeaders = CreateEventHeaders;
class CreateEventRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            description: 'description',
            end: 'end',
            extra: 'extra',
            isAllDay: 'isAllDay',
            location: 'location',
            onlineMeetingInfo: 'onlineMeetingInfo',
            recurrence: 'recurrence',
            reminders: 'reminders',
            start: 'start',
            summary: 'summary',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': CreateEventRequestAttendees },
            description: 'string',
            end: CreateEventRequestEnd,
            extra: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            isAllDay: 'boolean',
            location: CreateEventRequestLocation,
            onlineMeetingInfo: CreateEventRequestOnlineMeetingInfo,
            recurrence: CreateEventRequestRecurrence,
            reminders: { 'type': 'array', 'itemType': CreateEventRequestReminders },
            start: CreateEventRequestStart,
            summary: 'string',
        };
    }
}
exports.CreateEventRequest = CreateEventRequest;
class CreateEventResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            createTime: 'createTime',
            description: 'description',
            end: 'end',
            id: 'id',
            isAllDay: 'isAllDay',
            location: 'location',
            onlineMeetingInfo: 'onlineMeetingInfo',
            organizer: 'organizer',
            recurrence: 'recurrence',
            reminders: 'reminders',
            start: 'start',
            summary: 'summary',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': CreateEventResponseBodyAttendees },
            createTime: 'string',
            description: 'string',
            end: CreateEventResponseBodyEnd,
            id: 'string',
            isAllDay: 'boolean',
            location: CreateEventResponseBodyLocation,
            onlineMeetingInfo: CreateEventResponseBodyOnlineMeetingInfo,
            organizer: CreateEventResponseBodyOrganizer,
            recurrence: CreateEventResponseBodyRecurrence,
            reminders: { 'type': 'array', 'itemType': CreateEventResponseBodyReminders },
            start: CreateEventResponseBodyStart,
            summary: 'string',
            updateTime: 'string',
        };
    }
}
exports.CreateEventResponseBody = CreateEventResponseBody;
class CreateEventResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateEventResponseBody,
        };
    }
}
exports.CreateEventResponse = CreateEventResponse;
class CreateSubscribedCalendarHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateSubscribedCalendarHeaders = CreateSubscribedCalendarHeaders;
class CreateSubscribedCalendarRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            managers: 'managers',
            name: 'name',
            subscribeScope: 'subscribeScope',
        };
    }
    static types() {
        return {
            description: 'string',
            managers: { 'type': 'array', 'itemType': 'string' },
            name: 'string',
            subscribeScope: CreateSubscribedCalendarRequestSubscribeScope,
        };
    }
}
exports.CreateSubscribedCalendarRequest = CreateSubscribedCalendarRequest;
class CreateSubscribedCalendarResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            calendarId: 'calendarId',
        };
    }
    static types() {
        return {
            calendarId: 'string',
        };
    }
}
exports.CreateSubscribedCalendarResponseBody = CreateSubscribedCalendarResponseBody;
class CreateSubscribedCalendarResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: CreateSubscribedCalendarResponseBody,
        };
    }
}
exports.CreateSubscribedCalendarResponse = CreateSubscribedCalendarResponse;
class DeleteAclHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteAclHeaders = DeleteAclHeaders;
class DeleteAclResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.DeleteAclResponse = DeleteAclResponse;
class DeleteEventHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteEventHeaders = DeleteEventHeaders;
class DeleteEventResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.DeleteEventResponse = DeleteEventResponse;
class DeleteSubscribedCalendarHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteSubscribedCalendarHeaders = DeleteSubscribedCalendarHeaders;
class DeleteSubscribedCalendarResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.DeleteSubscribedCalendarResponseBody = DeleteSubscribedCalendarResponseBody;
class DeleteSubscribedCalendarResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: DeleteSubscribedCalendarResponseBody,
        };
    }
}
exports.DeleteSubscribedCalendarResponse = DeleteSubscribedCalendarResponse;
class GenerateCaldavAccountHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            dingUid: 'dingUid',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            dingUid: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GenerateCaldavAccountHeaders = GenerateCaldavAccountHeaders;
class GenerateCaldavAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            device: 'device',
        };
    }
    static types() {
        return {
            device: 'string',
        };
    }
}
exports.GenerateCaldavAccountRequest = GenerateCaldavAccountRequest;
class GenerateCaldavAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            password: 'password',
            serverAddress: 'serverAddress',
            username: 'username',
        };
    }
    static types() {
        return {
            password: 'string',
            serverAddress: 'string',
            username: 'string',
        };
    }
}
exports.GenerateCaldavAccountResponseBody = GenerateCaldavAccountResponseBody;
class GenerateCaldavAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GenerateCaldavAccountResponseBody,
        };
    }
}
exports.GenerateCaldavAccountResponse = GenerateCaldavAccountResponse;
class GetEventHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetEventHeaders = GetEventHeaders;
class GetEventRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxAttendees: 'maxAttendees',
        };
    }
    static types() {
        return {
            maxAttendees: 'number',
        };
    }
}
exports.GetEventRequest = GetEventRequest;
class GetEventResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            createTime: 'createTime',
            description: 'description',
            end: 'end',
            id: 'id',
            isAllDay: 'isAllDay',
            location: 'location',
            onlineMeetingInfo: 'onlineMeetingInfo',
            organizer: 'organizer',
            recurrence: 'recurrence',
            reminders: 'reminders',
            seriesMasterId: 'seriesMasterId',
            start: 'start',
            status: 'status',
            summary: 'summary',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': GetEventResponseBodyAttendees },
            createTime: 'string',
            description: 'string',
            end: GetEventResponseBodyEnd,
            id: 'string',
            isAllDay: 'boolean',
            location: GetEventResponseBodyLocation,
            onlineMeetingInfo: GetEventResponseBodyOnlineMeetingInfo,
            organizer: GetEventResponseBodyOrganizer,
            recurrence: GetEventResponseBodyRecurrence,
            reminders: { 'type': 'array', 'itemType': GetEventResponseBodyReminders },
            seriesMasterId: 'string',
            start: GetEventResponseBodyStart,
            status: 'string',
            summary: 'string',
            updateTime: 'string',
        };
    }
}
exports.GetEventResponseBody = GetEventResponseBody;
class GetEventResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetEventResponseBody,
        };
    }
}
exports.GetEventResponse = GetEventResponse;
class GetScheduleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetScheduleHeaders = GetScheduleHeaders;
class GetScheduleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            endTime: 'string',
            startTime: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetScheduleRequest = GetScheduleRequest;
class GetScheduleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scheduleInformation: 'scheduleInformation',
        };
    }
    static types() {
        return {
            scheduleInformation: { 'type': 'array', 'itemType': GetScheduleResponseBodyScheduleInformation },
        };
    }
}
exports.GetScheduleResponseBody = GetScheduleResponseBody;
class GetScheduleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetScheduleResponseBody,
        };
    }
}
exports.GetScheduleResponse = GetScheduleResponse;
class GetSignInListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSignInListHeaders = GetSignInListHeaders;
class GetSignInListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            type: 'type',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            type: 'string',
        };
    }
}
exports.GetSignInListRequest = GetSignInListRequest;
class GetSignInListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            users: 'users',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            users: { 'type': 'array', 'itemType': GetSignInListResponseBodyUsers },
        };
    }
}
exports.GetSignInListResponseBody = GetSignInListResponseBody;
class GetSignInListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetSignInListResponseBody,
        };
    }
}
exports.GetSignInListResponse = GetSignInListResponse;
class GetSignOutListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSignOutListHeaders = GetSignOutListHeaders;
class GetSignOutListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            type: 'type',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            type: 'string',
        };
    }
}
exports.GetSignOutListRequest = GetSignOutListRequest;
class GetSignOutListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            users: 'users',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            users: { 'type': 'array', 'itemType': GetSignOutListResponseBodyUsers },
        };
    }
}
exports.GetSignOutListResponseBody = GetSignOutListResponseBody;
class GetSignOutListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetSignOutListResponseBody,
        };
    }
}
exports.GetSignOutListResponse = GetSignOutListResponse;
class GetSubscribedCalendarHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSubscribedCalendarHeaders = GetSubscribedCalendarHeaders;
class GetSubscribedCalendarResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            author: 'author',
            calendarId: 'calendarId',
            description: 'description',
            managers: 'managers',
            name: 'name',
            subscribeScope: 'subscribeScope',
        };
    }
    static types() {
        return {
            author: 'string',
            calendarId: 'string',
            description: 'string',
            managers: { 'type': 'array', 'itemType': 'string' },
            name: 'string',
            subscribeScope: GetSubscribedCalendarResponseBodySubscribeScope,
        };
    }
}
exports.GetSubscribedCalendarResponseBody = GetSubscribedCalendarResponseBody;
class GetSubscribedCalendarResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetSubscribedCalendarResponseBody,
        };
    }
}
exports.GetSubscribedCalendarResponse = GetSubscribedCalendarResponse;
class ListAclsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListAclsHeaders = ListAclsHeaders;
class ListAclsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acls: 'acls',
        };
    }
    static types() {
        return {
            acls: { 'type': 'array', 'itemType': ListAclsResponseBodyAcls },
        };
    }
}
exports.ListAclsResponseBody = ListAclsResponseBody;
class ListAclsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListAclsResponseBody,
        };
    }
}
exports.ListAclsResponse = ListAclsResponse;
class ListAttendeesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListAttendeesHeaders = ListAttendeesHeaders;
class ListAttendeesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.ListAttendeesRequest = ListAttendeesRequest;
class ListAttendeesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': ListAttendeesResponseBodyAttendees },
            nextToken: 'string',
        };
    }
}
exports.ListAttendeesResponseBody = ListAttendeesResponseBody;
class ListAttendeesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListAttendeesResponseBody,
        };
    }
}
exports.ListAttendeesResponse = ListAttendeesResponse;
class ListCalendarsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListCalendarsHeaders = ListCalendarsHeaders;
class ListCalendarsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            response: 'response',
        };
    }
    static types() {
        return {
            response: ListCalendarsResponseBodyResponse,
        };
    }
}
exports.ListCalendarsResponseBody = ListCalendarsResponseBody;
class ListCalendarsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListCalendarsResponseBody,
        };
    }
}
exports.ListCalendarsResponse = ListCalendarsResponse;
class ListEventsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListEventsHeaders = ListEventsHeaders;
class ListEventsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxAttendees: 'maxAttendees',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            showDeleted: 'showDeleted',
            syncToken: 'syncToken',
            timeMax: 'timeMax',
            timeMin: 'timeMin',
        };
    }
    static types() {
        return {
            maxAttendees: 'number',
            maxResults: 'number',
            nextToken: 'string',
            showDeleted: 'boolean',
            syncToken: 'string',
            timeMax: 'string',
            timeMin: 'string',
        };
    }
}
exports.ListEventsRequest = ListEventsRequest;
class ListEventsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            events: 'events',
            nextToken: 'nextToken',
            syncToken: 'syncToken',
        };
    }
    static types() {
        return {
            events: { 'type': 'array', 'itemType': ListEventsResponseBodyEvents },
            nextToken: 'string',
            syncToken: 'string',
        };
    }
}
exports.ListEventsResponseBody = ListEventsResponseBody;
class ListEventsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListEventsResponseBody,
        };
    }
}
exports.ListEventsResponse = ListEventsResponse;
class ListEventsInstancesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListEventsInstancesHeaders = ListEventsInstancesHeaders;
class ListEventsInstancesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxAttendees: 'maxAttendees',
            maxResults: 'maxResults',
            seriesMasterId: 'seriesMasterId',
            startRecurrenceId: 'startRecurrenceId',
        };
    }
    static types() {
        return {
            maxAttendees: 'number',
            maxResults: 'number',
            seriesMasterId: 'string',
            startRecurrenceId: 'string',
        };
    }
}
exports.ListEventsInstancesRequest = ListEventsInstancesRequest;
class ListEventsInstancesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            events: 'events',
        };
    }
    static types() {
        return {
            events: { 'type': 'array', 'itemType': ListEventsInstancesResponseBodyEvents },
        };
    }
}
exports.ListEventsInstancesResponseBody = ListEventsInstancesResponseBody;
class ListEventsInstancesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListEventsInstancesResponseBody,
        };
    }
}
exports.ListEventsInstancesResponse = ListEventsInstancesResponse;
class ListEventsViewHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListEventsViewHeaders = ListEventsViewHeaders;
class ListEventsViewRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxAttendees: 'maxAttendees',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            timeMax: 'timeMax',
            timeMin: 'timeMin',
        };
    }
    static types() {
        return {
            maxAttendees: 'number',
            maxResults: 'number',
            nextToken: 'string',
            timeMax: 'string',
            timeMin: 'string',
        };
    }
}
exports.ListEventsViewRequest = ListEventsViewRequest;
class ListEventsViewResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            events: 'events',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            events: { 'type': 'array', 'itemType': ListEventsViewResponseBodyEvents },
            nextToken: 'string',
        };
    }
}
exports.ListEventsViewResponseBody = ListEventsViewResponseBody;
class ListEventsViewResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ListEventsViewResponseBody,
        };
    }
}
exports.ListEventsViewResponse = ListEventsViewResponse;
class PatchEventHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PatchEventHeaders = PatchEventHeaders;
class PatchEventRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            description: 'description',
            end: 'end',
            extra: 'extra',
            id: 'id',
            isAllDay: 'isAllDay',
            location: 'location',
            recurrence: 'recurrence',
            reminders: 'reminders',
            start: 'start',
            summary: 'summary',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': PatchEventRequestAttendees },
            description: 'string',
            end: PatchEventRequestEnd,
            extra: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            id: 'string',
            isAllDay: 'boolean',
            location: PatchEventRequestLocation,
            recurrence: PatchEventRequestRecurrence,
            reminders: { 'type': 'array', 'itemType': PatchEventRequestReminders },
            start: PatchEventRequestStart,
            summary: 'string',
        };
    }
}
exports.PatchEventRequest = PatchEventRequest;
class PatchEventResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            createTime: 'createTime',
            description: 'description',
            end: 'end',
            id: 'id',
            isAllDay: 'isAllDay',
            location: 'location',
            organizer: 'organizer',
            recurrence: 'recurrence',
            reminders: 'reminders',
            start: 'start',
            summary: 'summary',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': PatchEventResponseBodyAttendees },
            createTime: 'string',
            description: 'string',
            end: PatchEventResponseBodyEnd,
            id: 'string',
            isAllDay: 'boolean',
            location: PatchEventResponseBodyLocation,
            organizer: PatchEventResponseBodyOrganizer,
            recurrence: PatchEventResponseBodyRecurrence,
            reminders: { 'type': 'array', 'itemType': PatchEventResponseBodyReminders },
            start: PatchEventResponseBodyStart,
            summary: 'string',
            updateTime: 'string',
        };
    }
}
exports.PatchEventResponseBody = PatchEventResponseBody;
class PatchEventResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: PatchEventResponseBody,
        };
    }
}
exports.PatchEventResponse = PatchEventResponse;
class RemoveAttendeeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RemoveAttendeeHeaders = RemoveAttendeeHeaders;
class RemoveAttendeeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendeesToRemove: 'attendeesToRemove',
        };
    }
    static types() {
        return {
            attendeesToRemove: { 'type': 'array', 'itemType': RemoveAttendeeRequestAttendeesToRemove },
        };
    }
}
exports.RemoveAttendeeRequest = RemoveAttendeeRequest;
class RemoveAttendeeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.RemoveAttendeeResponse = RemoveAttendeeResponse;
class RespondEventHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RespondEventHeaders = RespondEventHeaders;
class RespondEventRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            responseStatus: 'responseStatus',
        };
    }
    static types() {
        return {
            responseStatus: 'string',
        };
    }
}
exports.RespondEventRequest = RespondEventRequest;
class RespondEventResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.RespondEventResponse = RespondEventResponse;
class SignInHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SignInHeaders = SignInHeaders;
class SignInResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkInTime: 'checkInTime',
        };
    }
    static types() {
        return {
            checkInTime: 'number',
        };
    }
}
exports.SignInResponseBody = SignInResponseBody;
class SignInResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SignInResponseBody,
        };
    }
}
exports.SignInResponse = SignInResponse;
class SignOutHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SignOutHeaders = SignOutHeaders;
class SignOutResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkOutTime: 'checkOutTime',
        };
    }
    static types() {
        return {
            checkOutTime: 'number',
        };
    }
}
exports.SignOutResponseBody = SignOutResponseBody;
class SignOutResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: SignOutResponseBody,
        };
    }
}
exports.SignOutResponse = SignOutResponse;
class SubscribeCalendarHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SubscribeCalendarHeaders = SubscribeCalendarHeaders;
class SubscribeCalendarResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.SubscribeCalendarResponse = SubscribeCalendarResponse;
class UpdateSubscribedCalendarsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateSubscribedCalendarsHeaders = UpdateSubscribedCalendarsHeaders;
class UpdateSubscribedCalendarsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            managers: 'managers',
            name: 'name',
            subscribeScope: 'subscribeScope',
        };
    }
    static types() {
        return {
            description: 'string',
            managers: { 'type': 'array', 'itemType': 'string' },
            name: 'string',
            subscribeScope: UpdateSubscribedCalendarsRequestSubscribeScope,
        };
    }
}
exports.UpdateSubscribedCalendarsRequest = UpdateSubscribedCalendarsRequest;
class UpdateSubscribedCalendarsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.UpdateSubscribedCalendarsResponseBody = UpdateSubscribedCalendarsResponseBody;
class UpdateSubscribedCalendarsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateSubscribedCalendarsResponseBody,
        };
    }
}
exports.UpdateSubscribedCalendarsResponse = UpdateSubscribedCalendarsResponse;
class AddAttendeeRequestAttendeesToAdd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            isOptional: 'isOptional',
        };
    }
    static types() {
        return {
            id: 'string',
            isOptional: 'boolean',
        };
    }
}
exports.AddAttendeeRequestAttendeesToAdd = AddAttendeeRequestAttendeesToAdd;
class CreateAclsRequestScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scopeType: 'scopeType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            scopeType: 'string',
            userId: 'string',
        };
    }
}
exports.CreateAclsRequestScope = CreateAclsRequestScope;
class CreateAclsResponseBodyScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scopeType: 'scopeType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            scopeType: 'string',
            userId: 'string',
        };
    }
}
exports.CreateAclsResponseBodyScope = CreateAclsResponseBodyScope;
class CreateEventRequestAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            isOptional: 'isOptional',
        };
    }
    static types() {
        return {
            id: 'string',
            isOptional: 'boolean',
        };
    }
}
exports.CreateEventRequestAttendees = CreateEventRequestAttendees;
class CreateEventRequestEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.CreateEventRequestEnd = CreateEventRequestEnd;
class CreateEventRequestLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
        };
    }
    static types() {
        return {
            displayName: 'string',
        };
    }
}
exports.CreateEventRequestLocation = CreateEventRequestLocation;
class CreateEventRequestOnlineMeetingInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
}
exports.CreateEventRequestOnlineMeetingInfo = CreateEventRequestOnlineMeetingInfo;
class CreateEventRequestRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.CreateEventRequestRecurrencePattern = CreateEventRequestRecurrencePattern;
class CreateEventRequestRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.CreateEventRequestRecurrenceRange = CreateEventRequestRecurrenceRange;
class CreateEventRequestRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: CreateEventRequestRecurrencePattern,
            range: CreateEventRequestRecurrenceRange,
        };
    }
}
exports.CreateEventRequestRecurrence = CreateEventRequestRecurrence;
class CreateEventRequestReminders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            minutes: 'minutes',
        };
    }
    static types() {
        return {
            method: 'string',
            minutes: 'number',
        };
    }
}
exports.CreateEventRequestReminders = CreateEventRequestReminders;
class CreateEventRequestStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.CreateEventRequestStart = CreateEventRequestStart;
class CreateEventResponseBodyAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            isOptional: 'isOptional',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            isOptional: 'boolean',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.CreateEventResponseBodyAttendees = CreateEventResponseBodyAttendees;
class CreateEventResponseBodyEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.CreateEventResponseBodyEnd = CreateEventResponseBodyEnd;
class CreateEventResponseBodyLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
        };
    }
    static types() {
        return {
            displayName: 'string',
        };
    }
}
exports.CreateEventResponseBodyLocation = CreateEventResponseBodyLocation;
class CreateEventResponseBodyOnlineMeetingInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            extraInfo: 'extraInfo',
            type: 'type',
            url: 'url',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            type: 'string',
            url: 'string',
        };
    }
}
exports.CreateEventResponseBodyOnlineMeetingInfo = CreateEventResponseBodyOnlineMeetingInfo;
class CreateEventResponseBodyOrganizer extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.CreateEventResponseBodyOrganizer = CreateEventResponseBodyOrganizer;
class CreateEventResponseBodyRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.CreateEventResponseBodyRecurrencePattern = CreateEventResponseBodyRecurrencePattern;
class CreateEventResponseBodyRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.CreateEventResponseBodyRecurrenceRange = CreateEventResponseBodyRecurrenceRange;
class CreateEventResponseBodyRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: CreateEventResponseBodyRecurrencePattern,
            range: CreateEventResponseBodyRecurrenceRange,
        };
    }
}
exports.CreateEventResponseBodyRecurrence = CreateEventResponseBodyRecurrence;
class CreateEventResponseBodyReminders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            minutes: 'minutes',
        };
    }
    static types() {
        return {
            method: 'string',
            minutes: 'string',
        };
    }
}
exports.CreateEventResponseBodyReminders = CreateEventResponseBodyReminders;
class CreateEventResponseBodyStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.CreateEventResponseBodyStart = CreateEventResponseBodyStart;
class CreateSubscribedCalendarRequestSubscribeScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpIds: 'corpIds',
            openConversationIds: 'openConversationIds',
            unionIds: 'unionIds',
        };
    }
    static types() {
        return {
            corpIds: { 'type': 'array', 'itemType': 'string' },
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            unionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.CreateSubscribedCalendarRequestSubscribeScope = CreateSubscribedCalendarRequestSubscribeScope;
class GetEventResponseBodyAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            isOptional: 'isOptional',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            isOptional: 'boolean',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.GetEventResponseBodyAttendees = GetEventResponseBodyAttendees;
class GetEventResponseBodyEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.GetEventResponseBodyEnd = GetEventResponseBodyEnd;
class GetEventResponseBodyLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            meetingRooms: 'meetingRooms',
        };
    }
    static types() {
        return {
            displayName: 'string',
            meetingRooms: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetEventResponseBodyLocation = GetEventResponseBodyLocation;
class GetEventResponseBodyOnlineMeetingInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            extraInfo: 'extraInfo',
            type: 'type',
            url: 'url',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            type: 'string',
            url: 'string',
        };
    }
}
exports.GetEventResponseBodyOnlineMeetingInfo = GetEventResponseBodyOnlineMeetingInfo;
class GetEventResponseBodyOrganizer extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.GetEventResponseBodyOrganizer = GetEventResponseBodyOrganizer;
class GetEventResponseBodyRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.GetEventResponseBodyRecurrencePattern = GetEventResponseBodyRecurrencePattern;
class GetEventResponseBodyRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.GetEventResponseBodyRecurrenceRange = GetEventResponseBodyRecurrenceRange;
class GetEventResponseBodyRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: GetEventResponseBodyRecurrencePattern,
            range: GetEventResponseBodyRecurrenceRange,
        };
    }
}
exports.GetEventResponseBodyRecurrence = GetEventResponseBodyRecurrence;
class GetEventResponseBodyReminders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            minutes: 'minutes',
        };
    }
    static types() {
        return {
            method: 'string',
            minutes: 'string',
        };
    }
}
exports.GetEventResponseBodyReminders = GetEventResponseBodyReminders;
class GetEventResponseBodyStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.GetEventResponseBodyStart = GetEventResponseBodyStart;
class GetScheduleResponseBodyScheduleInformationScheduleItemsEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.GetScheduleResponseBodyScheduleInformationScheduleItemsEnd = GetScheduleResponseBodyScheduleInformationScheduleItemsEnd;
class GetScheduleResponseBodyScheduleInformationScheduleItemsStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.GetScheduleResponseBodyScheduleInformationScheduleItemsStart = GetScheduleResponseBodyScheduleInformationScheduleItemsStart;
class GetScheduleResponseBodyScheduleInformationScheduleItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            end: 'end',
            start: 'start',
            status: 'status',
        };
    }
    static types() {
        return {
            end: GetScheduleResponseBodyScheduleInformationScheduleItemsEnd,
            start: GetScheduleResponseBodyScheduleInformationScheduleItemsStart,
            status: 'string',
        };
    }
}
exports.GetScheduleResponseBodyScheduleInformationScheduleItems = GetScheduleResponseBodyScheduleInformationScheduleItems;
class GetScheduleResponseBodyScheduleInformation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            error: 'error',
            scheduleItems: 'scheduleItems',
            userId: 'userId',
        };
    }
    static types() {
        return {
            error: 'string',
            scheduleItems: { 'type': 'array', 'itemType': GetScheduleResponseBodyScheduleInformationScheduleItems },
            userId: 'string',
        };
    }
}
exports.GetScheduleResponseBodyScheduleInformation = GetScheduleResponseBodyScheduleInformation;
class GetSignInListResponseBodyUsers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkInTime: 'checkInTime',
            displayName: 'displayName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            checkInTime: 'number',
            displayName: 'string',
            userId: 'string',
        };
    }
}
exports.GetSignInListResponseBodyUsers = GetSignInListResponseBodyUsers;
class GetSignOutListResponseBodyUsers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkOutTime: 'checkOutTime',
            displayName: 'displayName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            checkOutTime: 'number',
            displayName: 'string',
            userId: 'string',
        };
    }
}
exports.GetSignOutListResponseBodyUsers = GetSignOutListResponseBodyUsers;
class GetSubscribedCalendarResponseBodySubscribeScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpIds: 'corpIds',
            openConversationIds: 'openConversationIds',
            unionIds: 'unionIds',
        };
    }
    static types() {
        return {
            corpIds: { 'type': 'array', 'itemType': 'string' },
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            unionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetSubscribedCalendarResponseBodySubscribeScope = GetSubscribedCalendarResponseBodySubscribeScope;
class ListAclsResponseBodyAclsScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scopeType: 'scopeType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            scopeType: 'string',
            userId: 'string',
        };
    }
}
exports.ListAclsResponseBodyAclsScope = ListAclsResponseBodyAclsScope;
class ListAclsResponseBodyAcls extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aclId: 'aclId',
            privilege: 'privilege',
            scope: 'scope',
        };
    }
    static types() {
        return {
            aclId: 'string',
            privilege: 'string',
            scope: ListAclsResponseBodyAclsScope,
        };
    }
}
exports.ListAclsResponseBodyAcls = ListAclsResponseBodyAcls;
class ListAttendeesResponseBodyAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            isOptional: 'isOptional',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            isOptional: 'boolean',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.ListAttendeesResponseBodyAttendees = ListAttendeesResponseBodyAttendees;
class ListCalendarsResponseBodyResponseCalendars extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            eTag: 'eTag',
            id: 'id',
            privilege: 'privilege',
            summary: 'summary',
            timeZone: 'timeZone',
            type: 'type',
        };
    }
    static types() {
        return {
            description: 'string',
            eTag: 'string',
            id: 'string',
            privilege: 'string',
            summary: 'string',
            timeZone: 'string',
            type: 'string',
        };
    }
}
exports.ListCalendarsResponseBodyResponseCalendars = ListCalendarsResponseBodyResponseCalendars;
class ListCalendarsResponseBodyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            calendars: 'calendars',
        };
    }
    static types() {
        return {
            calendars: { 'type': 'array', 'itemType': ListCalendarsResponseBodyResponseCalendars },
        };
    }
}
exports.ListCalendarsResponseBodyResponse = ListCalendarsResponseBodyResponse;
class ListEventsResponseBodyEventsAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            isOptional: 'isOptional',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            isOptional: 'boolean',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.ListEventsResponseBodyEventsAttendees = ListEventsResponseBodyEventsAttendees;
class ListEventsResponseBodyEventsEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.ListEventsResponseBodyEventsEnd = ListEventsResponseBodyEventsEnd;
class ListEventsResponseBodyEventsLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            meetingRooms: 'meetingRooms',
        };
    }
    static types() {
        return {
            displayName: 'string',
            meetingRooms: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ListEventsResponseBodyEventsLocation = ListEventsResponseBodyEventsLocation;
class ListEventsResponseBodyEventsOnlineMeetingInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            extraInfo: 'extraInfo',
            type: 'type',
            url: 'url',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            type: 'string',
            url: 'string',
        };
    }
}
exports.ListEventsResponseBodyEventsOnlineMeetingInfo = ListEventsResponseBodyEventsOnlineMeetingInfo;
class ListEventsResponseBodyEventsOrganizer extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.ListEventsResponseBodyEventsOrganizer = ListEventsResponseBodyEventsOrganizer;
class ListEventsResponseBodyEventsRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.ListEventsResponseBodyEventsRecurrencePattern = ListEventsResponseBodyEventsRecurrencePattern;
class ListEventsResponseBodyEventsRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.ListEventsResponseBodyEventsRecurrenceRange = ListEventsResponseBodyEventsRecurrenceRange;
class ListEventsResponseBodyEventsRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: ListEventsResponseBodyEventsRecurrencePattern,
            range: ListEventsResponseBodyEventsRecurrenceRange,
        };
    }
}
exports.ListEventsResponseBodyEventsRecurrence = ListEventsResponseBodyEventsRecurrence;
class ListEventsResponseBodyEventsReminders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            minutes: 'minutes',
        };
    }
    static types() {
        return {
            method: 'string',
            minutes: 'string',
        };
    }
}
exports.ListEventsResponseBodyEventsReminders = ListEventsResponseBodyEventsReminders;
class ListEventsResponseBodyEventsStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.ListEventsResponseBodyEventsStart = ListEventsResponseBodyEventsStart;
class ListEventsResponseBodyEvents extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            createTime: 'createTime',
            description: 'description',
            end: 'end',
            id: 'id',
            isAllDay: 'isAllDay',
            location: 'location',
            onlineMeetingInfo: 'onlineMeetingInfo',
            organizer: 'organizer',
            recurrence: 'recurrence',
            reminders: 'reminders',
            seriesMasterId: 'seriesMasterId',
            start: 'start',
            status: 'status',
            summary: 'summary',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': ListEventsResponseBodyEventsAttendees },
            createTime: 'string',
            description: 'string',
            end: ListEventsResponseBodyEventsEnd,
            id: 'string',
            isAllDay: 'boolean',
            location: ListEventsResponseBodyEventsLocation,
            onlineMeetingInfo: ListEventsResponseBodyEventsOnlineMeetingInfo,
            organizer: ListEventsResponseBodyEventsOrganizer,
            recurrence: ListEventsResponseBodyEventsRecurrence,
            reminders: { 'type': 'array', 'itemType': ListEventsResponseBodyEventsReminders },
            seriesMasterId: 'string',
            start: ListEventsResponseBodyEventsStart,
            status: 'string',
            summary: 'string',
            updateTime: 'string',
        };
    }
}
exports.ListEventsResponseBodyEvents = ListEventsResponseBodyEvents;
class ListEventsInstancesResponseBodyEventsAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            isOptional: 'isOptional',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            isOptional: 'boolean',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsAttendees = ListEventsInstancesResponseBodyEventsAttendees;
class ListEventsInstancesResponseBodyEventsEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsEnd = ListEventsInstancesResponseBodyEventsEnd;
class ListEventsInstancesResponseBodyEventsLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            meetingRooms: 'meetingRooms',
        };
    }
    static types() {
        return {
            displayName: 'string',
            meetingRooms: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsLocation = ListEventsInstancesResponseBodyEventsLocation;
class ListEventsInstancesResponseBodyEventsOnlineMeetingInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            type: 'type',
            url: 'url',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            type: 'string',
            url: 'string',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsOnlineMeetingInfo = ListEventsInstancesResponseBodyEventsOnlineMeetingInfo;
class ListEventsInstancesResponseBodyEventsOrganizer extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsOrganizer = ListEventsInstancesResponseBodyEventsOrganizer;
class ListEventsInstancesResponseBodyEventsRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsRecurrencePattern = ListEventsInstancesResponseBodyEventsRecurrencePattern;
class ListEventsInstancesResponseBodyEventsRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsRecurrenceRange = ListEventsInstancesResponseBodyEventsRecurrenceRange;
class ListEventsInstancesResponseBodyEventsRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: ListEventsInstancesResponseBodyEventsRecurrencePattern,
            range: ListEventsInstancesResponseBodyEventsRecurrenceRange,
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsRecurrence = ListEventsInstancesResponseBodyEventsRecurrence;
class ListEventsInstancesResponseBodyEventsReminders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            minutes: 'minutes',
        };
    }
    static types() {
        return {
            method: 'string',
            minutes: 'string',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsReminders = ListEventsInstancesResponseBodyEventsReminders;
class ListEventsInstancesResponseBodyEventsStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.ListEventsInstancesResponseBodyEventsStart = ListEventsInstancesResponseBodyEventsStart;
class ListEventsInstancesResponseBodyEvents extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            createTime: 'createTime',
            description: 'description',
            end: 'end',
            id: 'id',
            isAllDay: 'isAllDay',
            location: 'location',
            onlineMeetingInfo: 'onlineMeetingInfo',
            organizer: 'organizer',
            recurrence: 'recurrence',
            reminders: 'reminders',
            seriesMasterId: 'seriesMasterId',
            start: 'start',
            status: 'status',
            summary: 'summary',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': ListEventsInstancesResponseBodyEventsAttendees },
            createTime: 'string',
            description: 'string',
            end: ListEventsInstancesResponseBodyEventsEnd,
            id: 'string',
            isAllDay: 'boolean',
            location: ListEventsInstancesResponseBodyEventsLocation,
            onlineMeetingInfo: ListEventsInstancesResponseBodyEventsOnlineMeetingInfo,
            organizer: ListEventsInstancesResponseBodyEventsOrganizer,
            recurrence: ListEventsInstancesResponseBodyEventsRecurrence,
            reminders: { 'type': 'array', 'itemType': ListEventsInstancesResponseBodyEventsReminders },
            seriesMasterId: 'string',
            start: ListEventsInstancesResponseBodyEventsStart,
            status: 'string',
            summary: 'string',
            updateTime: 'string',
        };
    }
}
exports.ListEventsInstancesResponseBodyEvents = ListEventsInstancesResponseBodyEvents;
class ListEventsViewResponseBodyEventsAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            isOptional: 'isOptional',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            isOptional: 'boolean',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.ListEventsViewResponseBodyEventsAttendees = ListEventsViewResponseBodyEventsAttendees;
class ListEventsViewResponseBodyEventsEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.ListEventsViewResponseBodyEventsEnd = ListEventsViewResponseBodyEventsEnd;
class ListEventsViewResponseBodyEventsLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            meetingRooms: 'meetingRooms',
        };
    }
    static types() {
        return {
            displayName: 'string',
            meetingRooms: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ListEventsViewResponseBodyEventsLocation = ListEventsViewResponseBodyEventsLocation;
class ListEventsViewResponseBodyEventsOnlineMeetingInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            extraInfo: 'extraInfo',
            type: 'type',
            url: 'url',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            type: 'string',
            url: 'string',
        };
    }
}
exports.ListEventsViewResponseBodyEventsOnlineMeetingInfo = ListEventsViewResponseBodyEventsOnlineMeetingInfo;
class ListEventsViewResponseBodyEventsOrganizer extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.ListEventsViewResponseBodyEventsOrganizer = ListEventsViewResponseBodyEventsOrganizer;
class ListEventsViewResponseBodyEventsRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.ListEventsViewResponseBodyEventsRecurrencePattern = ListEventsViewResponseBodyEventsRecurrencePattern;
class ListEventsViewResponseBodyEventsRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.ListEventsViewResponseBodyEventsRecurrenceRange = ListEventsViewResponseBodyEventsRecurrenceRange;
class ListEventsViewResponseBodyEventsRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: ListEventsViewResponseBodyEventsRecurrencePattern,
            range: ListEventsViewResponseBodyEventsRecurrenceRange,
        };
    }
}
exports.ListEventsViewResponseBodyEventsRecurrence = ListEventsViewResponseBodyEventsRecurrence;
class ListEventsViewResponseBodyEventsStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.ListEventsViewResponseBodyEventsStart = ListEventsViewResponseBodyEventsStart;
class ListEventsViewResponseBodyEvents extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendees: 'attendees',
            createTime: 'createTime',
            description: 'description',
            end: 'end',
            id: 'id',
            isAllDay: 'isAllDay',
            location: 'location',
            onlineMeetingInfo: 'onlineMeetingInfo',
            organizer: 'organizer',
            recurrence: 'recurrence',
            seriesMasterId: 'seriesMasterId',
            start: 'start',
            status: 'status',
            summary: 'summary',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            attendees: { 'type': 'array', 'itemType': ListEventsViewResponseBodyEventsAttendees },
            createTime: 'string',
            description: 'string',
            end: ListEventsViewResponseBodyEventsEnd,
            id: 'string',
            isAllDay: 'boolean',
            location: ListEventsViewResponseBodyEventsLocation,
            onlineMeetingInfo: ListEventsViewResponseBodyEventsOnlineMeetingInfo,
            organizer: ListEventsViewResponseBodyEventsOrganizer,
            recurrence: ListEventsViewResponseBodyEventsRecurrence,
            seriesMasterId: 'string',
            start: ListEventsViewResponseBodyEventsStart,
            status: 'string',
            summary: 'string',
            updateTime: 'string',
        };
    }
}
exports.ListEventsViewResponseBodyEvents = ListEventsViewResponseBodyEvents;
class PatchEventRequestAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            isOptional: 'isOptional',
        };
    }
    static types() {
        return {
            id: 'string',
            isOptional: 'boolean',
        };
    }
}
exports.PatchEventRequestAttendees = PatchEventRequestAttendees;
class PatchEventRequestEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.PatchEventRequestEnd = PatchEventRequestEnd;
class PatchEventRequestLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
        };
    }
    static types() {
        return {
            displayName: 'string',
        };
    }
}
exports.PatchEventRequestLocation = PatchEventRequestLocation;
class PatchEventRequestRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.PatchEventRequestRecurrencePattern = PatchEventRequestRecurrencePattern;
class PatchEventRequestRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.PatchEventRequestRecurrenceRange = PatchEventRequestRecurrenceRange;
class PatchEventRequestRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: PatchEventRequestRecurrencePattern,
            range: PatchEventRequestRecurrenceRange,
        };
    }
}
exports.PatchEventRequestRecurrence = PatchEventRequestRecurrence;
class PatchEventRequestReminders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            minutes: 'minutes',
        };
    }
    static types() {
        return {
            method: 'string',
            minutes: 'number',
        };
    }
}
exports.PatchEventRequestReminders = PatchEventRequestReminders;
class PatchEventRequestStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.PatchEventRequestStart = PatchEventRequestStart;
class PatchEventResponseBodyAttendees extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            isOptional: 'isOptional',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            isOptional: 'boolean',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.PatchEventResponseBodyAttendees = PatchEventResponseBodyAttendees;
class PatchEventResponseBodyEnd extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.PatchEventResponseBodyEnd = PatchEventResponseBodyEnd;
class PatchEventResponseBodyLocation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            meetingRooms: 'meetingRooms',
        };
    }
    static types() {
        return {
            displayName: 'string',
            meetingRooms: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.PatchEventResponseBodyLocation = PatchEventResponseBodyLocation;
class PatchEventResponseBodyOrganizer extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayName: 'displayName',
            id: 'id',
            responseStatus: 'responseStatus',
            self: 'self',
        };
    }
    static types() {
        return {
            displayName: 'string',
            id: 'string',
            responseStatus: 'string',
            self: 'boolean',
        };
    }
}
exports.PatchEventResponseBodyOrganizer = PatchEventResponseBodyOrganizer;
class PatchEventResponseBodyRecurrencePattern extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dayOfMonth: 'dayOfMonth',
            daysOfWeek: 'daysOfWeek',
            index: 'index',
            interval: 'interval',
            type: 'type',
        };
    }
    static types() {
        return {
            dayOfMonth: 'number',
            daysOfWeek: 'string',
            index: 'string',
            interval: 'number',
            type: 'string',
        };
    }
}
exports.PatchEventResponseBodyRecurrencePattern = PatchEventResponseBodyRecurrencePattern;
class PatchEventResponseBodyRecurrenceRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endDate: 'endDate',
            numberOfOccurrences: 'numberOfOccurrences',
            type: 'type',
        };
    }
    static types() {
        return {
            endDate: 'string',
            numberOfOccurrences: 'number',
            type: 'string',
        };
    }
}
exports.PatchEventResponseBodyRecurrenceRange = PatchEventResponseBodyRecurrenceRange;
class PatchEventResponseBodyRecurrence extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pattern: 'pattern',
            range: 'range',
        };
    }
    static types() {
        return {
            pattern: PatchEventResponseBodyRecurrencePattern,
            range: PatchEventResponseBodyRecurrenceRange,
        };
    }
}
exports.PatchEventResponseBodyRecurrence = PatchEventResponseBodyRecurrence;
class PatchEventResponseBodyReminders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            method: 'method',
            minutes: 'minutes',
        };
    }
    static types() {
        return {
            method: 'string',
            minutes: 'string',
        };
    }
}
exports.PatchEventResponseBodyReminders = PatchEventResponseBodyReminders;
class PatchEventResponseBodyStart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            dateTime: 'dateTime',
            timeZone: 'timeZone',
        };
    }
    static types() {
        return {
            date: 'string',
            dateTime: 'string',
            timeZone: 'string',
        };
    }
}
exports.PatchEventResponseBodyStart = PatchEventResponseBodyStart;
class RemoveAttendeeRequestAttendeesToRemove extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
}
exports.RemoveAttendeeRequestAttendeesToRemove = RemoveAttendeeRequestAttendeesToRemove;
class UpdateSubscribedCalendarsRequestSubscribeScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpIds: 'corpIds',
            openConversationIds: 'openConversationIds',
            unionIds: 'unionIds',
        };
    }
    static types() {
        return {
            corpIds: { 'type': 'array', 'itemType': 'string' },
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            unionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UpdateSubscribedCalendarsRequestSubscribeScope = UpdateSubscribedCalendarsRequestSubscribeScope;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addAttendee(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddAttendeeHeaders({});
        return await this.addAttendeeWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async addAttendeeWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.attendeesToAdd)) {
            body["attendeesToAdd"] = request.attendeesToAdd;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddAttendee", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/attendees`, "none", req, runtime), new AddAttendeeResponse({}));
    }
    async checkIn(userId, calendarId, eventId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CheckInHeaders({});
        return await this.checkInWithOptions(userId, calendarId, eventId, headers, runtime);
    }
    async checkInWithOptions(userId, calendarId, eventId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("CheckIn", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/checkIn`, "json", req, runtime), new CheckInResponse({}));
    }
    async convertLegacyEventId(userId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ConvertLegacyEventIdHeaders({});
        return await this.convertLegacyEventIdWithOptions(userId, request, headers, runtime);
    }
    async convertLegacyEventIdWithOptions(userId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.legacyEventIds)) {
            body["legacyEventIds"] = request.legacyEventIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("ConvertLegacyEventId", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/legacyEventIds/convert`, "json", req, runtime), new ConvertLegacyEventIdResponse({}));
    }
    async createAcls(userId, calendarId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateAclsHeaders({});
        return await this.createAclsWithOptions(userId, calendarId, request, headers, runtime);
    }
    async createAclsWithOptions(userId, calendarId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.privilege)) {
            body["privilege"] = request.privilege;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.scope))) {
            body["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.sendMsg)) {
            body["sendMsg"] = request.sendMsg;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateAcls", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/acls`, "json", req, runtime), new CreateAclsResponse({}));
    }
    async createEvent(userId, calendarId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateEventHeaders({});
        return await this.createEventWithOptions(userId, calendarId, request, headers, runtime);
    }
    async createEventWithOptions(userId, calendarId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.attendees)) {
            body["attendees"] = request.attendees;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.end))) {
            body["end"] = request.end;
        }
        if (!tea_util_1.default.isUnset(request.extra)) {
            body["extra"] = request.extra;
        }
        if (!tea_util_1.default.isUnset(request.isAllDay)) {
            body["isAllDay"] = request.isAllDay;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.location))) {
            body["location"] = request.location;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.onlineMeetingInfo))) {
            body["onlineMeetingInfo"] = request.onlineMeetingInfo;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.recurrence))) {
            body["recurrence"] = request.recurrence;
        }
        if (!tea_util_1.default.isUnset(request.reminders)) {
            body["reminders"] = request.reminders;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.start))) {
            body["start"] = request.start;
        }
        if (!tea_util_1.default.isUnset(request.summary)) {
            body["summary"] = request.summary;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateEvent", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events`, "json", req, runtime), new CreateEventResponse({}));
    }
    async createSubscribedCalendar(userId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateSubscribedCalendarHeaders({});
        return await this.createSubscribedCalendarWithOptions(userId, request, headers, runtime);
    }
    async createSubscribedCalendarWithOptions(userId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.managers)) {
            body["managers"] = request.managers;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.subscribeScope))) {
            body["subscribeScope"] = request.subscribeScope;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("CreateSubscribedCalendar", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/subscribedCalendars`, "json", req, runtime), new CreateSubscribedCalendarResponse({}));
    }
    async deleteAcl(userId, calendarId, aclId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteAclHeaders({});
        return await this.deleteAclWithOptions(userId, calendarId, aclId, headers, runtime);
    }
    async deleteAclWithOptions(userId, calendarId, aclId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        aclId = openapi_util_1.default.getEncodeParam(aclId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("DeleteAcl", "calendar_1.0", "HTTP", "DELETE", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/acls/${aclId}`, "none", req, runtime), new DeleteAclResponse({}));
    }
    async deleteEvent(userId, calendarId, eventId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteEventHeaders({});
        return await this.deleteEventWithOptions(userId, calendarId, eventId, headers, runtime);
    }
    async deleteEventWithOptions(userId, calendarId, eventId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("DeleteEvent", "calendar_1.0", "HTTP", "DELETE", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}`, "none", req, runtime), new DeleteEventResponse({}));
    }
    async deleteSubscribedCalendar(userId, calendarId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteSubscribedCalendarHeaders({});
        return await this.deleteSubscribedCalendarWithOptions(userId, calendarId, headers, runtime);
    }
    async deleteSubscribedCalendarWithOptions(userId, calendarId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("DeleteSubscribedCalendar", "calendar_1.0", "HTTP", "DELETE", "AK", `/v1.0/calendar/users/${userId}/subscribedCalendars/${calendarId}`, "json", req, runtime), new DeleteSubscribedCalendarResponse({}));
    }
    async generateCaldavAccount(userId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GenerateCaldavAccountHeaders({});
        return await this.generateCaldavAccountWithOptions(userId, request, headers, runtime);
    }
    async generateCaldavAccountWithOptions(userId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.device)) {
            body["device"] = request.device;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.dingUid)) {
            realHeaders["dingUid"] = tea_util_1.default.toJSONString(headers.dingUid);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GenerateCaldavAccount", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/caldavAccounts`, "json", req, runtime), new GenerateCaldavAccountResponse({}));
    }
    async getEvent(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetEventHeaders({});
        return await this.getEventWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async getEventWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxAttendees)) {
            query["maxAttendees"] = request.maxAttendees;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetEvent", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}`, "json", req, runtime), new GetEventResponse({}));
    }
    async getSchedule(userId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetScheduleHeaders({});
        return await this.getScheduleWithOptions(userId, request, headers, runtime);
    }
    async getScheduleWithOptions(userId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("GetSchedule", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/querySchedule`, "json", req, runtime), new GetScheduleResponse({}));
    }
    async getSignInList(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSignInListHeaders({});
        return await this.getSignInListWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async getSignInListWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetSignInList", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/signin`, "json", req, runtime), new GetSignInListResponse({}));
    }
    async getSignOutList(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSignOutListHeaders({});
        return await this.getSignOutListWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async getSignOutListWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetSignOutList", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/signOut`, "json", req, runtime), new GetSignOutListResponse({}));
    }
    async getSubscribedCalendar(userId, calendarId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSubscribedCalendarHeaders({});
        return await this.getSubscribedCalendarWithOptions(userId, calendarId, headers, runtime);
    }
    async getSubscribedCalendarWithOptions(userId, calendarId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("GetSubscribedCalendar", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/subscribedCalendars/${calendarId}`, "json", req, runtime), new GetSubscribedCalendarResponse({}));
    }
    async listAcls(userId, calendarId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAclsHeaders({});
        return await this.listAclsWithOptions(userId, calendarId, headers, runtime);
    }
    async listAclsWithOptions(userId, calendarId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("ListAcls", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/acls`, "json", req, runtime), new ListAclsResponse({}));
    }
    async listAttendees(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAttendeesHeaders({});
        return await this.listAttendeesWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async listAttendeesWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListAttendees", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/attendees`, "json", req, runtime), new ListAttendeesResponse({}));
    }
    async listCalendars(userId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListCalendarsHeaders({});
        return await this.listCalendarsWithOptions(userId, headers, runtime);
    }
    async listCalendarsWithOptions(userId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("ListCalendars", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars`, "json", req, runtime), new ListCalendarsResponse({}));
    }
    async listEvents(userId, calendarId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListEventsHeaders({});
        return await this.listEventsWithOptions(userId, calendarId, request, headers, runtime);
    }
    async listEventsWithOptions(userId, calendarId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxAttendees)) {
            query["maxAttendees"] = request.maxAttendees;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.showDeleted)) {
            query["showDeleted"] = request.showDeleted;
        }
        if (!tea_util_1.default.isUnset(request.syncToken)) {
            query["syncToken"] = request.syncToken;
        }
        if (!tea_util_1.default.isUnset(request.timeMax)) {
            query["timeMax"] = request.timeMax;
        }
        if (!tea_util_1.default.isUnset(request.timeMin)) {
            query["timeMin"] = request.timeMin;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListEvents", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events`, "json", req, runtime), new ListEventsResponse({}));
    }
    async listEventsInstances(userId, calendarId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListEventsInstancesHeaders({});
        return await this.listEventsInstancesWithOptions(userId, calendarId, request, headers, runtime);
    }
    async listEventsInstancesWithOptions(userId, calendarId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxAttendees)) {
            query["maxAttendees"] = request.maxAttendees;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.seriesMasterId)) {
            query["seriesMasterId"] = request.seriesMasterId;
        }
        if (!tea_util_1.default.isUnset(request.startRecurrenceId)) {
            query["startRecurrenceId"] = request.startRecurrenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListEventsInstances", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/instances`, "json", req, runtime), new ListEventsInstancesResponse({}));
    }
    async listEventsView(userId, calendarId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListEventsViewHeaders({});
        return await this.listEventsViewWithOptions(userId, calendarId, request, headers, runtime);
    }
    async listEventsViewWithOptions(userId, calendarId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxAttendees)) {
            query["maxAttendees"] = request.maxAttendees;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.timeMax)) {
            query["timeMax"] = request.timeMax;
        }
        if (!tea_util_1.default.isUnset(request.timeMin)) {
            query["timeMin"] = request.timeMin;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ListEventsView", "calendar_1.0", "HTTP", "GET", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/eventsview`, "json", req, runtime), new ListEventsViewResponse({}));
    }
    async patchEvent(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PatchEventHeaders({});
        return await this.patchEventWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async patchEventWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.attendees)) {
            body["attendees"] = request.attendees;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.end))) {
            body["end"] = request.end;
        }
        if (!tea_util_1.default.isUnset(request.extra)) {
            body["extra"] = request.extra;
        }
        if (!tea_util_1.default.isUnset(request.id)) {
            body["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.isAllDay)) {
            body["isAllDay"] = request.isAllDay;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.location))) {
            body["location"] = request.location;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.recurrence))) {
            body["recurrence"] = request.recurrence;
        }
        if (!tea_util_1.default.isUnset(request.reminders)) {
            body["reminders"] = request.reminders;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.start))) {
            body["start"] = request.start;
        }
        if (!tea_util_1.default.isUnset(request.summary)) {
            body["summary"] = request.summary;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("PatchEvent", "calendar_1.0", "HTTP", "PUT", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}`, "json", req, runtime), new PatchEventResponse({}));
    }
    async removeAttendee(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RemoveAttendeeHeaders({});
        return await this.removeAttendeeWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async removeAttendeeWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.attendeesToRemove)) {
            body["attendeesToRemove"] = request.attendeesToRemove;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RemoveAttendee", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/attendees/batchRemove`, "none", req, runtime), new RemoveAttendeeResponse({}));
    }
    async respondEvent(userId, calendarId, eventId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RespondEventHeaders({});
        return await this.respondEventWithOptions(userId, calendarId, eventId, request, headers, runtime);
    }
    async respondEventWithOptions(userId, calendarId, eventId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.responseStatus)) {
            body["responseStatus"] = request.responseStatus;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("RespondEvent", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/respond`, "none", req, runtime), new RespondEventResponse({}));
    }
    async signIn(userId, calendarId, eventId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SignInHeaders({});
        return await this.signInWithOptions(userId, calendarId, eventId, headers, runtime);
    }
    async signInWithOptions(userId, calendarId, eventId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("SignIn", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/signin`, "json", req, runtime), new SignInResponse({}));
    }
    async signOut(userId, calendarId, eventId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SignOutHeaders({});
        return await this.signOutWithOptions(userId, calendarId, eventId, headers, runtime);
    }
    async signOutWithOptions(userId, calendarId, eventId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        eventId = openapi_util_1.default.getEncodeParam(eventId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("SignOut", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/events/${eventId}/signOut`, "json", req, runtime), new SignOutResponse({}));
    }
    async subscribeCalendar(userId, calendarId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SubscribeCalendarHeaders({});
        return await this.subscribeCalendarWithOptions(userId, calendarId, headers, runtime);
    }
    async subscribeCalendarWithOptions(userId, calendarId, headers, runtime) {
        userId = openapi_util_1.default.getEncodeParam(userId);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        return $tea.cast(await this.doROARequest("SubscribeCalendar", "calendar_1.0", "HTTP", "POST", "AK", `/v1.0/calendar/users/${userId}/calendars/${calendarId}/subscribe`, "none", req, runtime), new SubscribeCalendarResponse({}));
    }
    async updateSubscribedCalendars(calendarId, userId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateSubscribedCalendarsHeaders({});
        return await this.updateSubscribedCalendarsWithOptions(calendarId, userId, request, headers, runtime);
    }
    async updateSubscribedCalendarsWithOptions(calendarId, userId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        calendarId = openapi_util_1.default.getEncodeParam(calendarId);
        userId = openapi_util_1.default.getEncodeParam(userId);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.managers)) {
            body["managers"] = request.managers;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.subscribeScope))) {
            body["subscribeScope"] = request.subscribeScope;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateSubscribedCalendars", "calendar_1.0", "HTTP", "PUT", "AK", `/v1.0/calendar/users/${userId}/subscribedCalendars/${calendarId}`, "json", req, runtime), new UpdateSubscribedCalendarsResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map