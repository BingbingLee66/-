"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddApplicationRegFormTemplateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddApplicationRegFormTemplateHeaders = AddApplicationRegFormTemplateHeaders;
class AddApplicationRegFormTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            content: 'content',
            name: 'name',
            outerId: 'outerId',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            content: 'string',
            name: 'string',
            outerId: 'string',
            opUserId: 'string',
        };
    }
}
exports.AddApplicationRegFormTemplateRequest = AddApplicationRegFormTemplateRequest;
class AddApplicationRegFormTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            templateId: 'templateId',
            version: 'version',
        };
    }
    static types() {
        return {
            templateId: 'string',
            version: 'number',
        };
    }
}
exports.AddApplicationRegFormTemplateResponseBody = AddApplicationRegFormTemplateResponseBody;
class AddApplicationRegFormTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddApplicationRegFormTemplateResponseBody,
        };
    }
}
exports.AddApplicationRegFormTemplateResponse = AddApplicationRegFormTemplateResponse;
class AddFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddFileHeaders = AddFileHeaders;
class AddFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            fileName: 'fileName',
            mediaId: 'mediaId',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            fileName: 'string',
            mediaId: 'string',
            opUserId: 'string',
        };
    }
}
exports.AddFileRequest = AddFileRequest;
class AddFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            fileName: 'fileName',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            fileId: 'string',
            fileName: 'string',
            spaceId: 'number',
        };
    }
}
exports.AddFileResponseBody = AddFileResponseBody;
class AddFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: AddFileResponseBody,
        };
    }
}
exports.AddFileResponse = AddFileResponse;
class ConfirmRightsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ConfirmRightsHeaders = ConfirmRightsHeaders;
class ConfirmRightsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
        };
    }
    static types() {
        return {
            bizCode: 'string',
        };
    }
}
exports.ConfirmRightsRequest = ConfirmRightsRequest;
class ConfirmRightsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.ConfirmRightsResponseBody = ConfirmRightsResponseBody;
class ConfirmRightsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: ConfirmRightsResponseBody,
        };
    }
}
exports.ConfirmRightsResponse = ConfirmRightsResponse;
class FinishBeginnerTaskHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.FinishBeginnerTaskHeaders = FinishBeginnerTaskHeaders;
class FinishBeginnerTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scope: 'scope',
            userId: 'userId',
        };
    }
    static types() {
        return {
            scope: 'string',
            userId: 'string',
        };
    }
}
exports.FinishBeginnerTaskRequest = FinishBeginnerTaskRequest;
class FinishBeginnerTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.FinishBeginnerTaskResponseBody = FinishBeginnerTaskResponseBody;
class FinishBeginnerTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: FinishBeginnerTaskResponseBody,
        };
    }
}
exports.FinishBeginnerTaskResponse = FinishBeginnerTaskResponse;
class GetApplicationRegFormByFlowIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetApplicationRegFormByFlowIdHeaders = GetApplicationRegFormByFlowIdHeaders;
class GetApplicationRegFormByFlowIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
        };
    }
    static types() {
        return {
            bizCode: 'string',
        };
    }
}
exports.GetApplicationRegFormByFlowIdRequest = GetApplicationRegFormByFlowIdRequest;
class GetApplicationRegFormByFlowIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            candidateId: 'candidateId',
            creatorUserId: 'creatorUserId',
            flowId: 'flowId',
            formId: 'formId',
            gmtCreateMillis: 'gmtCreateMillis',
            gmtModifiedMillis: 'gmtModifiedMillis',
            jobId: 'jobId',
            status: 'status',
            templateId: 'templateId',
            templateVersion: 'templateVersion',
        };
    }
    static types() {
        return {
            candidateId: 'string',
            creatorUserId: 'string',
            flowId: 'string',
            formId: 'string',
            gmtCreateMillis: 'number',
            gmtModifiedMillis: 'number',
            jobId: 'string',
            status: 'number',
            templateId: 'string',
            templateVersion: 'number',
        };
    }
}
exports.GetApplicationRegFormByFlowIdResponseBody = GetApplicationRegFormByFlowIdResponseBody;
class GetApplicationRegFormByFlowIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetApplicationRegFormByFlowIdResponseBody,
        };
    }
}
exports.GetApplicationRegFormByFlowIdResponse = GetApplicationRegFormByFlowIdResponse;
class GetCandidateByPhoneNumberHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCandidateByPhoneNumberHeaders = GetCandidateByPhoneNumberHeaders;
class GetCandidateByPhoneNumberRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            phoneNumber: 'phoneNumber',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            phoneNumber: 'string',
        };
    }
}
exports.GetCandidateByPhoneNumberRequest = GetCandidateByPhoneNumberRequest;
class GetCandidateByPhoneNumberResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            candidateId: 'candidateId',
            name: 'name',
        };
    }
    static types() {
        return {
            candidateId: 'string',
            name: 'string',
        };
    }
}
exports.GetCandidateByPhoneNumberResponseBody = GetCandidateByPhoneNumberResponseBody;
class GetCandidateByPhoneNumberResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetCandidateByPhoneNumberResponseBody,
        };
    }
}
exports.GetCandidateByPhoneNumberResponse = GetCandidateByPhoneNumberResponse;
class GetFileUploadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileUploadInfoHeaders = GetFileUploadInfoHeaders;
class GetFileUploadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            fileName: 'fileName',
            fileSize: 'fileSize',
            md5: 'md5',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            fileName: 'string',
            fileSize: 'number',
            md5: 'string',
            opUserId: 'string',
        };
    }
}
exports.GetFileUploadInfoRequest = GetFileUploadInfoRequest;
class GetFileUploadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accessKeyId: 'accessKeyId',
            accessKeySecret: 'accessKeySecret',
            accessToken: 'accessToken',
            accessTokenExpirationMillis: 'accessTokenExpirationMillis',
            bucket: 'bucket',
            endPoint: 'endPoint',
            mediaId: 'mediaId',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            accessKeySecret: 'string',
            accessToken: 'string',
            accessTokenExpirationMillis: 'number',
            bucket: 'string',
            endPoint: 'string',
            mediaId: 'string',
        };
    }
}
exports.GetFileUploadInfoResponseBody = GetFileUploadInfoResponseBody;
class GetFileUploadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetFileUploadInfoResponseBody,
        };
    }
}
exports.GetFileUploadInfoResponse = GetFileUploadInfoResponse;
class GetFlowIdByRelationEntityIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFlowIdByRelationEntityIdHeaders = GetFlowIdByRelationEntityIdHeaders;
class GetFlowIdByRelationEntityIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            relationEntity: 'relationEntity',
            relationEntityId: 'relationEntityId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            relationEntity: 'string',
            relationEntityId: 'string',
        };
    }
}
exports.GetFlowIdByRelationEntityIdRequest = GetFlowIdByRelationEntityIdRequest;
class GetFlowIdByRelationEntityIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            flowId: 'flowId',
        };
    }
    static types() {
        return {
            flowId: 'string',
        };
    }
}
exports.GetFlowIdByRelationEntityIdResponseBody = GetFlowIdByRelationEntityIdResponseBody;
class GetFlowIdByRelationEntityIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetFlowIdByRelationEntityIdResponseBody,
        };
    }
}
exports.GetFlowIdByRelationEntityIdResponse = GetFlowIdByRelationEntityIdResponse;
class GetJobAuthHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetJobAuthHeaders = GetJobAuthHeaders;
class GetJobAuthRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            opUserId: 'string',
        };
    }
}
exports.GetJobAuthRequest = GetJobAuthRequest;
class GetJobAuthResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'jobId',
            jobOwners: 'jobOwners',
        };
    }
    static types() {
        return {
            jobId: 'string',
            jobOwners: { 'type': 'array', 'itemType': GetJobAuthResponseBodyJobOwners },
        };
    }
}
exports.GetJobAuthResponseBody = GetJobAuthResponseBody;
class GetJobAuthResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: GetJobAuthResponseBody,
        };
    }
}
exports.GetJobAuthResponse = GetJobAuthResponse;
class QueryInterviewsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryInterviewsHeaders = QueryInterviewsHeaders;
class QueryInterviewsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            candidateId: 'candidateId',
            startTimeBeginMillis: 'startTimeBeginMillis',
            startTimeEndMillis: 'startTimeEndMillis',
            nextToken: 'nextToken',
            size: 'size',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            candidateId: 'string',
            startTimeBeginMillis: 'number',
            startTimeEndMillis: 'number',
            nextToken: 'string',
            size: 'number',
        };
    }
}
exports.QueryInterviewsRequest = QueryInterviewsRequest;
class QueryInterviewsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryInterviewsResponseBodyList },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.QueryInterviewsResponseBody = QueryInterviewsResponseBody;
class QueryInterviewsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: QueryInterviewsResponseBody,
        };
    }
}
exports.QueryInterviewsResponse = QueryInterviewsResponse;
class UpdateApplicationRegFormHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateApplicationRegFormHeaders = UpdateApplicationRegFormHeaders;
class UpdateApplicationRegFormRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            content: 'content',
            dingPanFile: 'dingPanFile',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            content: 'string',
            dingPanFile: UpdateApplicationRegFormRequestDingPanFile,
        };
    }
}
exports.UpdateApplicationRegFormRequest = UpdateApplicationRegFormRequest;
class UpdateApplicationRegFormResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorUserId: 'creatorUserId',
            formId: 'formId',
            gmtCreateMillis: 'gmtCreateMillis',
            gmtModifiedMillis: 'gmtModifiedMillis',
            status: 'status',
            templateId: 'templateId',
            templateVersion: 'templateVersion',
        };
    }
    static types() {
        return {
            creatorUserId: 'string',
            formId: 'string',
            gmtCreateMillis: 'number',
            gmtModifiedMillis: 'number',
            status: 'number',
            templateId: 'string',
            templateVersion: 'number',
        };
    }
}
exports.UpdateApplicationRegFormResponseBody = UpdateApplicationRegFormResponseBody;
class UpdateApplicationRegFormResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: UpdateApplicationRegFormResponseBody,
        };
    }
}
exports.UpdateApplicationRegFormResponse = UpdateApplicationRegFormResponse;
class UpdateInterviewSignInInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateInterviewSignInInfoHeaders = UpdateInterviewSignInInfoHeaders;
class UpdateInterviewSignInInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            signInTimeMillis: 'signInTimeMillis',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            signInTimeMillis: 'number',
        };
    }
}
exports.UpdateInterviewSignInInfoRequest = UpdateInterviewSignInInfoRequest;
class UpdateInterviewSignInInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.UpdateInterviewSignInInfoResponse = UpdateInterviewSignInInfoResponse;
class GetJobAuthResponseBodyJobOwners extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.GetJobAuthResponseBodyJobOwners = GetJobAuthResponseBodyJobOwners;
class QueryInterviewsResponseBodyListInterviewers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.QueryInterviewsResponseBodyListInterviewers = QueryInterviewsResponseBodyListInterviewers;
class QueryInterviewsResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cancelled: 'cancelled',
            creatorUserId: 'creatorUserId',
            endTimeMillis: 'endTimeMillis',
            interviewId: 'interviewId',
            interviewers: 'interviewers',
            jobId: 'jobId',
            startTimeMillis: 'startTimeMillis',
        };
    }
    static types() {
        return {
            cancelled: 'boolean',
            creatorUserId: 'string',
            endTimeMillis: 'number',
            interviewId: 'string',
            interviewers: { 'type': 'array', 'itemType': QueryInterviewsResponseBodyListInterviewers },
            jobId: 'string',
            startTimeMillis: 'number',
        };
    }
}
exports.QueryInterviewsResponseBodyList = QueryInterviewsResponseBodyList;
class UpdateApplicationRegFormRequestDingPanFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            fileName: 'fileName',
            fileSize: 'fileSize',
            fileType: 'fileType',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            fileId: 'string',
            fileName: 'string',
            fileSize: 'number',
            fileType: 'string',
            spaceId: 'number',
        };
    }
}
exports.UpdateApplicationRegFormRequestDingPanFile = UpdateApplicationRegFormRequestDingPanFile;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addApplicationRegFormTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddApplicationRegFormTemplateHeaders({});
        return await this.addApplicationRegFormTemplateWithOptions(request, headers, runtime);
    }
    async addApplicationRegFormTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddApplicationRegFormTemplate", "ats_1.0", "HTTP", "POST", "AK", `/v1.0/ats/flows/applicationRegForms/templates`, "json", req, runtime), new AddApplicationRegFormTemplateResponse({}));
    }
    async addFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddFileHeaders({});
        return await this.addFileWithOptions(request, headers, runtime);
    }
    async addFileWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.fileName)) {
            body["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            body["mediaId"] = request.mediaId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("AddFile", "ats_1.0", "HTTP", "POST", "AK", `/v1.0/ats/files`, "json", req, runtime), new AddFileResponse({}));
    }
    async confirmRights(rightsCode, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ConfirmRightsHeaders({});
        return await this.confirmRightsWithOptions(rightsCode, request, headers, runtime);
    }
    async confirmRightsWithOptions(rightsCode, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        rightsCode = openapi_util_1.default.getEncodeParam(rightsCode);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("ConfirmRights", "ats_1.0", "HTTP", "POST", "AK", `/v1.0/ats/rights/${rightsCode}/confirm`, "json", req, runtime), new ConfirmRightsResponse({}));
    }
    async finishBeginnerTask(taskCode, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new FinishBeginnerTaskHeaders({});
        return await this.finishBeginnerTaskWithOptions(taskCode, request, headers, runtime);
    }
    async finishBeginnerTaskWithOptions(taskCode, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        taskCode = openapi_util_1.default.getEncodeParam(taskCode);
        let query = {};
        if (!tea_util_1.default.isUnset(request.scope)) {
            query["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("FinishBeginnerTask", "ats_1.0", "HTTP", "POST", "AK", `/v1.0/ats/beginnerTasks/${taskCode}/finish`, "json", req, runtime), new FinishBeginnerTaskResponse({}));
    }
    async getApplicationRegFormByFlowId(flowId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetApplicationRegFormByFlowIdHeaders({});
        return await this.getApplicationRegFormByFlowIdWithOptions(flowId, request, headers, runtime);
    }
    async getApplicationRegFormByFlowIdWithOptions(flowId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        flowId = openapi_util_1.default.getEncodeParam(flowId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetApplicationRegFormByFlowId", "ats_1.0", "HTTP", "GET", "AK", `/v1.0/ats/flows/${flowId}/applicationRegForms`, "json", req, runtime), new GetApplicationRegFormByFlowIdResponse({}));
    }
    async getCandidateByPhoneNumber(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCandidateByPhoneNumberHeaders({});
        return await this.getCandidateByPhoneNumberWithOptions(request, headers, runtime);
    }
    async getCandidateByPhoneNumberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["phoneNumber"] = request.phoneNumber;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetCandidateByPhoneNumber", "ats_1.0", "HTTP", "GET", "AK", `/v1.0/ats/candidates`, "json", req, runtime), new GetCandidateByPhoneNumberResponse({}));
    }
    async getFileUploadInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileUploadInfoHeaders({});
        return await this.getFileUploadInfoWithOptions(request, headers, runtime);
    }
    async getFileUploadInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.fileSize)) {
            query["fileSize"] = request.fileSize;
        }
        if (!tea_util_1.default.isUnset(request.md5)) {
            query["md5"] = request.md5;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetFileUploadInfo", "ats_1.0", "HTTP", "GET", "AK", `/v1.0/ats/files/uploadInfos`, "json", req, runtime), new GetFileUploadInfoResponse({}));
    }
    async getFlowIdByRelationEntityId(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFlowIdByRelationEntityIdHeaders({});
        return await this.getFlowIdByRelationEntityIdWithOptions(request, headers, runtime);
    }
    async getFlowIdByRelationEntityIdWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.relationEntity)) {
            query["relationEntity"] = request.relationEntity;
        }
        if (!tea_util_1.default.isUnset(request.relationEntityId)) {
            query["relationEntityId"] = request.relationEntityId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetFlowIdByRelationEntityId", "ats_1.0", "HTTP", "GET", "AK", `/v1.0/ats/flows/ids`, "json", req, runtime), new GetFlowIdByRelationEntityIdResponse({}));
    }
    async getJobAuth(jobId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetJobAuthHeaders({});
        return await this.getJobAuthWithOptions(jobId, request, headers, runtime);
    }
    async getJobAuthWithOptions(jobId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        jobId = openapi_util_1.default.getEncodeParam(jobId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        return $tea.cast(await this.doROARequest("GetJobAuth", "ats_1.0", "HTTP", "GET", "AK", `/v1.0/ats/auths/jobs/${jobId}`, "json", req, runtime), new GetJobAuthResponse({}));
    }
    async queryInterviews(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryInterviewsHeaders({});
        return await this.queryInterviewsWithOptions(request, headers, runtime);
    }
    async queryInterviewsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.size)) {
            query["size"] = request.size;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.candidateId)) {
            body["candidateId"] = request.candidateId;
        }
        if (!tea_util_1.default.isUnset(request.startTimeBeginMillis)) {
            body["startTimeBeginMillis"] = request.startTimeBeginMillis;
        }
        if (!tea_util_1.default.isUnset(request.startTimeEndMillis)) {
            body["startTimeEndMillis"] = request.startTimeEndMillis;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("QueryInterviews", "ats_1.0", "HTTP", "POST", "AK", `/v1.0/ats/interviews/query`, "json", req, runtime), new QueryInterviewsResponse({}));
    }
    async updateApplicationRegForm(flowId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateApplicationRegFormHeaders({});
        return await this.updateApplicationRegFormWithOptions(flowId, request, headers, runtime);
    }
    async updateApplicationRegFormWithOptions(flowId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        flowId = openapi_util_1.default.getEncodeParam(flowId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset($tea.toMap(request.dingPanFile))) {
            body["dingPanFile"] = request.dingPanFile;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateApplicationRegForm", "ats_1.0", "HTTP", "PUT", "AK", `/v1.0/ats/flows/${flowId}/applicationRegForms`, "json", req, runtime), new UpdateApplicationRegFormResponse({}));
    }
    async updateInterviewSignInInfo(interviewId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateInterviewSignInInfoHeaders({});
        return await this.updateInterviewSignInInfoWithOptions(interviewId, request, headers, runtime);
    }
    async updateInterviewSignInInfoWithOptions(interviewId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        interviewId = openapi_util_1.default.getEncodeParam(interviewId);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.signInTimeMillis)) {
            body["signInTimeMillis"] = request.signInTimeMillis;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        return $tea.cast(await this.doROARequest("UpdateInterviewSignInInfo", "ats_1.0", "HTTP", "PUT", "AK", `/v1.0/ats/interviews/${interviewId}/signInInfos`, "none", req, runtime), new UpdateInterviewSignInInfoResponse({}));
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map